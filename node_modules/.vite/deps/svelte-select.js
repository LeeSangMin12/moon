import "./chunk-ELKJSBLM.js";
import "./chunk-ZFQZ7ZQJ.js";
import {
  action,
  add_locations,
  append_styles,
  attribute_effect,
  beforeUpdate,
  bind_prop,
  bind_this,
  bind_value,
  bubble_event,
  check_target,
  cleanup_styles,
  createEventDispatcher,
  each,
  hmr,
  if_block,
  index,
  init,
  legacy_api,
  onDestroy,
  onMount,
  prop,
  remove_input_defaults,
  sanitize_slots,
  set_attribute,
  set_class,
  set_style,
  set_value,
  slot
} from "./chunk-Z6FRCYMM.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html,
  from_svg,
  preventDefault,
  set_text,
  stopPropagation,
  text
} from "./chunk-6FWEO5PY.js";
import {
  $window,
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  deep_read_state,
  effect,
  event,
  first_child,
  get,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mutable_source,
  mutate,
  pop,
  push,
  reset,
  set,
  sibling,
  strict_equals,
  template_effect,
  tick,
  track_reactivity_loss,
  untrack
} from "./chunk-PFCY3FMS.js";
import "./chunk-55K7ITRW.js";
import "./chunk-HNWPC2PS.js";
import "./chunk-YBXDGRZT.js";
import "./chunk-K63UQA3V.js";
import "./chunk-HFZ37CMS.js";

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root5 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root5.clientWidth - (left + width));
    const insetBottom = floor(root5.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root5.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/svelte-floating-ui/index.js
function createFloatingActions(initOptions) {
  let referenceElement;
  let floatingElement;
  const defaultOptions = {
    autoUpdate: true
  };
  let options = initOptions;
  const getOptions = (mixin) => {
    return { ...defaultOptions, ...initOptions || {}, ...mixin || {} };
  };
  const updatePosition = (updateOptions) => {
    if (referenceElement && floatingElement) {
      options = getOptions(updateOptions);
      computePosition2(referenceElement, floatingElement, options).then((v) => {
        Object.assign(floatingElement.style, {
          position: v.strategy,
          left: `${v.x}px`,
          top: `${v.y}px`
        });
        (options == null ? void 0 : options.onComputed) && options.onComputed(v);
      });
    }
  };
  const referenceAction = (node) => {
    if ("subscribe" in node) {
      setupVirtualElementObserver(node);
      return {};
    } else {
      referenceElement = node;
      updatePosition();
    }
  };
  const contentAction = (node, contentOptions) => {
    let autoUpdateDestroy;
    floatingElement = node;
    options = getOptions(contentOptions);
    setTimeout(() => updatePosition(contentOptions), 0);
    updatePosition(contentOptions);
    const destroyAutoUpdate = () => {
      if (autoUpdateDestroy) {
        autoUpdateDestroy();
        autoUpdateDestroy = void 0;
      }
    };
    const initAutoUpdate = ({ autoUpdate: autoUpdate2 } = options || {}) => {
      destroyAutoUpdate();
      if (autoUpdate2 !== false) {
        tick().then(() => {
          return autoUpdate(referenceElement, floatingElement, () => updatePosition(options), autoUpdate2 === true ? {} : autoUpdate2);
        });
      }
      return;
    };
    autoUpdateDestroy = initAutoUpdate();
    return {
      update(contentOptions2) {
        updatePosition(contentOptions2);
        autoUpdateDestroy = initAutoUpdate(contentOptions2);
      },
      destroy() {
        destroyAutoUpdate();
      }
    };
  };
  const setupVirtualElementObserver = (node) => {
    const unsubscribe = node.subscribe(($node) => {
      if (referenceElement === void 0) {
        referenceElement = $node;
        updatePosition();
      } else {
        Object.assign(referenceElement, $node);
        updatePosition();
      }
    });
    onDestroy(unsubscribe);
  };
  return [
    referenceAction,
    contentAction,
    updatePosition
  ];
}

// node_modules/svelte-select/filter.js
function filter({
  loadOptions,
  filterText,
  items,
  multiple,
  value,
  itemId,
  groupBy,
  filterSelectedItems,
  itemFilter,
  convertStringItemsToObjects,
  filterGroupedItems,
  label
}) {
  if (items && loadOptions) return items;
  if (!items) return [];
  if (items && items.length > 0 && typeof items[0] !== "object") {
    items = convertStringItemsToObjects(items);
  }
  let filterResults = items.filter((item) => {
    let matchesFilter = itemFilter(item[label], filterText, item);
    if (matchesFilter && multiple && (value == null ? void 0 : value.length)) {
      matchesFilter = !value.some((x) => {
        return filterSelectedItems ? x[itemId] === item[itemId] : false;
      });
    }
    return matchesFilter;
  });
  if (groupBy) {
    filterResults = filterGroupedItems(filterResults);
  }
  return filterResults;
}

// node_modules/svelte-select/get-items.js
async function getItems({ dispatch, loadOptions, convertStringItemsToObjects, filterText }) {
  let res = await loadOptions(filterText).catch((err) => {
    console.warn("svelte-select loadOptions error :>> ", err);
    dispatch("error", { type: "loadOptions", details: err });
  });
  if (res && !res.cancelled) {
    if (res) {
      if (res && res.length > 0 && typeof res[0] !== "object") {
        res = convertStringItemsToObjects(res);
      }
      dispatch("loaded", { items: res });
    } else {
      res = [];
    }
    return {
      filteredItems: res,
      loading: false,
      focused: true,
      listOpen: true
    };
  }
}

// node_modules/svelte-select/ChevronIcon.svelte
ChevronIcon[FILENAME] = "node_modules/svelte-select/ChevronIcon.svelte";
var root = add_locations(
  from_svg(`<svg width="100%" height="100%" viewBox="0 0 20 20" focusable="false" aria-hidden="true" class="s-QgxznJPnsKqF"><path fill="currentColor" d="M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747
          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0
          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502
          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0
          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"></path></svg>`),
  ChevronIcon[FILENAME],
  [[1, 0, [[7, 4]]]]
);
var $$css = {
  hash: "s-QgxznJPnsKqF",
  code: "\n  svg.s-QgxznJPnsKqF {\n      width: var(--chevron-icon-width, 20px);\n      height: var(--chevron-icon-width, 20px);\n      color: var(--chevron-icon-colour, currentColor);\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hldnJvbkljb24uc3ZlbHRlIiwic291cmNlcyI6WyJDaGV2cm9uSWNvbi5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHN2Z1xuICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgIDxwYXRoXG4gICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0N1xuICAgICAgICAgIDMuOTA4LTMuNzQ3YzAuNTMzLTAuNDgxIDEuMTQxLTAuNDQ2IDEuNTc0IDAgMC40MzYgMC40NDUgMC40MDggMS4xOTcgMFxuICAgICAgICAgIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyXG4gICAgICAgICAgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMFxuICAgICAgICAgIDAtNC4yODctNC4wODQtNC42OTUtNC41MDJzLTAuNDM2LTEuMTcgMC0xLjYxNXpcIiAvPlxuPC9zdmc+XG5cbjxzdHlsZT5cbiAgc3ZnIHtcbiAgICAgIHdpZHRoOiB2YXIoLS1jaGV2cm9uLWljb24td2lkdGgsIDIwcHgpO1xuICAgICAgaGVpZ2h0OiB2YXIoLS1jaGV2cm9uLWljb24td2lkdGgsIDIwcHgpO1xuICAgICAgY29sb3I6IHZhcigtLWNoZXZyb24taWNvbi1jb2xvdXIsIGN1cnJlbnRDb2xvcik7XG4gIH1cbjwvc3R5bGU+Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFnQkEsRUFBRSxrQkFBRyxDQUFDO0FBQ04sTUFBTSxzQ0FBc0M7QUFDNUMsTUFBTSx1Q0FBdUM7QUFDN0MsTUFBTSwrQ0FBK0M7QUFDckQiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function ChevronIcon($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ChevronIcon);
  append_styles($$anchor, $$css);
  var svg = root();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronIcon = hmr(ChevronIcon, () => ChevronIcon[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-QgxznJPnsKqF");
    module.default[HMR].source = ChevronIcon[HMR].source;
    set(ChevronIcon[HMR].source, module.default[HMR].original);
  });
}
var ChevronIcon_default = ChevronIcon;

// node_modules/svelte-select/ClearIcon.svelte
ClearIcon[FILENAME] = "node_modules/svelte-select/ClearIcon.svelte";
var root2 = add_locations(
  from_svg(`<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" aria-hidden="true" role="presentation" class="s-DTAJLbx7YMGx"><path fill="currentColor" d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124
    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>`),
  ClearIcon[FILENAME],
  [[1, 0, [[9, 4]]]]
);
var $$css2 = {
  hash: "s-DTAJLbx7YMGx",
  code: "\n    svg.s-DTAJLbx7YMGx {\n        width: var(--clear-icon-width, 20px);\n        height: var(--clear-icon-width, 20px);\n        color: var(--clear-icon-color, currentColor);\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2xlYXJJY29uLnN2ZWx0ZSIsInNvdXJjZXMiOlsiQ2xlYXJJY29uLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3ZnXG4gICAgd2lkdGg9XCIxMDAlXCJcbiAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICB2aWV3Qm94PVwiLTIgLTIgNTAgNTBcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuPlxuICAgIDxwYXRoXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICBkPVwiTTM0LjkyMywzNy4yNTFMMjQsMjYuMzI4TDEzLjA3NywzNy4yNTFMOS40MzYsMzMuNjFsMTAuOTIzLTEwLjkyM0w5LjQzNiwxMS43NjVsMy42NDEtMy42NDFMMjQsMTkuMDQ3TDM0LjkyMyw4LjEyNFxuICAgIGwzLjY0MSwzLjY0MUwyNy42NDEsMjIuNjg4TDM4LjU2NCwzMy42MUwzNC45MjMsMzcuMjUxelwiXG4gICAgLz5cbjwvc3ZnPlxuXG48c3R5bGU+XG4gICAgc3ZnIHtcbiAgICAgICAgd2lkdGg6IHZhcigtLWNsZWFyLWljb24td2lkdGgsIDIwcHgpO1xuICAgICAgICBoZWlnaHQ6IHZhcigtLWNsZWFyLWljb24td2lkdGgsIDIwcHgpO1xuICAgICAgICBjb2xvcjogdmFyKC0tY2xlYXItaWNvbi1jb2xvciwgY3VycmVudENvbG9yKTtcbiAgICB9XG48L3N0eWxlPiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBZ0JBLElBQUksa0JBQUcsQ0FBQztBQUNSLFFBQVEsb0NBQW9DO0FBQzVDLFFBQVEscUNBQXFDO0FBQzdDLFFBQVEsNENBQTRDO0FBQ3BEIiwiaWdub3JlTGlzdCI6W119 */"
};
function ClearIcon($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ClearIcon);
  append_styles($$anchor, $$css2);
  var svg = root2();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClearIcon = hmr(ClearIcon, () => ClearIcon[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-DTAJLbx7YMGx");
    module.default[HMR].source = ClearIcon[HMR].source;
    set(ClearIcon[HMR].source, module.default[HMR].original);
  });
}
var ClearIcon_default = ClearIcon;

// node_modules/svelte-select/LoadingIcon.svelte
LoadingIcon[FILENAME] = "node_modules/svelte-select/LoadingIcon.svelte";
var root3 = add_locations(from_svg(`<svg class="loading s-uZFqudMWDmAq" viewBox="25 25 50 50"><circle class="circle_path s-uZFqudMWDmAq" cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10"></circle></svg>`), LoadingIcon[FILENAME], [[1, 0, [[2, 4]]]]);
var $$css3 = {
  hash: "s-uZFqudMWDmAq",
  code: "\n    .loading.s-uZFqudMWDmAq {\n        width: var(--spinner-width, 20px);\n        height: var(--spinner-height, 20px);\n        color: var(--spinner-color, var(--icons-color));\n        animation: s-uZFqudMWDmAq-rotate 0.75s linear infinite;\n        transform-origin: center center;\n        transform: none;\n    }\n\n    .circle_path.s-uZFqudMWDmAq {\n        stroke-dasharray: 90;\n        stroke-linecap: round;\n    }\n\n    @keyframes s-uZFqudMWDmAq-rotate {\n        100% {\n            transform: rotate(360deg);\n        }\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGluZ0ljb24uc3ZlbHRlIiwic291cmNlcyI6WyJMb2FkaW5nSWNvbi5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHN2ZyBjbGFzcz1cImxvYWRpbmdcIiB2aWV3Qm94PVwiMjUgMjUgNTAgNTBcIj5cbiAgICA8Y2lyY2xlXG4gICAgICAgIGNsYXNzPVwiY2lyY2xlX3BhdGhcIlxuICAgICAgICBjeD1cIjUwXCJcbiAgICAgICAgY3k9XCI1MFwiXG4gICAgICAgIHI9XCIyMFwiXG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgc3Ryb2tlLXdpZHRoPVwiNVwiXG4gICAgICAgIHN0cm9rZS1taXRlcmxpbWl0PVwiMTBcIiAvPlxuPC9zdmc+XG5cbjxzdHlsZT5cbiAgICAubG9hZGluZyB7XG4gICAgICAgIHdpZHRoOiB2YXIoLS1zcGlubmVyLXdpZHRoLCAyMHB4KTtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1zcGlubmVyLWhlaWdodCwgMjBweCk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1zcGlubmVyLWNvbG9yLCB2YXIoLS1pY29ucy1jb2xvcikpO1xuICAgICAgICBhbmltYXRpb246IHJvdGF0ZSAwLjc1cyBsaW5lYXIgaW5maW5pdGU7XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gICAgICAgIHRyYW5zZm9ybTogbm9uZTtcbiAgICB9XG5cbiAgICAuY2lyY2xlX3BhdGgge1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA5MDtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xuICAgIH1cblxuICAgIEBrZXlmcmFtZXMgcm90YXRlIHtcbiAgICAgICAgMTAwJSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgICAgICB9XG4gICAgfVxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQWFBLElBQUksdUJBQVEsQ0FBQztBQUNiLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsbUNBQW1DO0FBQzNDLFFBQVEsK0NBQStDO0FBQ3ZELFFBQVEsMEJBQVcsNEJBQTRCO0FBQy9DLFFBQVEsK0JBQStCO0FBQ3ZDLFFBQVEsZUFBZTtBQUN2Qjs7QUFFQSxJQUFJLDJCQUFZLENBQUM7QUFDakIsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxxQkFBcUI7QUFDN0I7O0FBRUEsSUFBSSwwQkFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBIiwiaWdub3JlTGlzdCI6W119 */"
};
function LoadingIcon($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, LoadingIcon);
  append_styles($$anchor, $$css3);
  var svg = root3();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LoadingIcon = hmr(LoadingIcon, () => LoadingIcon[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-uZFqudMWDmAq");
    module.default[HMR].source = LoadingIcon[HMR].source;
    set(LoadingIcon[HMR].source, module.default[HMR].original);
  });
}
var LoadingIcon_default = LoadingIcon;

// node_modules/svelte-select/Select.svelte
Select[FILENAME] = "node_modules/svelte-select/Select.svelte";
var root_6 = add_locations(from_html(`<div class="list-item s-413vZPMk7oiT" tabindex="-1" role="none"><div><!></div></div>`), Select[FILENAME], [[700, 20, [[708, 24]]]]);
var root_10 = add_locations(from_html(`<div class="empty s-413vZPMk7oiT">No options</div>`), Select[FILENAME], [[726, 20]]);
var root_1 = add_locations(from_html(`<div role="none"><!> <!> <!></div>`), Select[FILENAME], [[687, 8]]);
var root_12 = add_locations(from_html(`<span id="aria-selection" class="s-413vZPMk7oiT"> </span> <span id="aria-context" class="s-413vZPMk7oiT"> </span>`, 1), Select[FILENAME], [[735, 12], [736, 12]]);
var root_17 = add_locations(from_html(`<div class="multi-item-clear s-413vZPMk7oiT"><!></div>`), Select[FILENAME], [[764, 28]]);
var root_15 = add_locations(from_html(`<div role="none"><span class="multi-item-text s-413vZPMk7oiT"><!></span> <!></div>`), Select[FILENAME], [[750, 20, [[757, 24]]]]);
var root_19 = add_locations(from_html(`<div><!></div>`), Select[FILENAME], [[775, 16]]);
var root_21 = add_locations(from_html(`<div class="icon loading s-413vZPMk7oiT" aria-hidden="true"><!></div>`), Select[FILENAME], [[798, 12]]);
var root_23 = add_locations(from_html(`<button type="button" class="icon clear-select s-413vZPMk7oiT"><!></button>`), Select[FILENAME], [[806, 12]]);
var root_25 = add_locations(from_html(`<div class="icon chevron s-413vZPMk7oiT" aria-hidden="true"><!></div>`), Select[FILENAME], [[814, 12]]);
var root_27 = add_locations(from_html(`<input type="hidden" class="s-413vZPMk7oiT"/>`), Select[FILENAME], [[823, 8]]);
var root_29 = add_locations(from_html(`<select class="required s-413vZPMk7oiT" required tabindex="-1" aria-hidden="true"></select>`), Select[FILENAME], [[828, 12]]);
var root4 = add_locations(from_html(`<div role="none"><!> <span aria-live="polite" aria-atomic="false" aria-relevant="additions text" class="a11y-text s-413vZPMk7oiT"><!></span> <div class="prepend s-413vZPMk7oiT"><!></div> <div class="value-container s-413vZPMk7oiT"><!> <input/></div> <div class="indicators s-413vZPMk7oiT"><!> <!> <!></div> <!> <!></div>`), Select[FILENAME], [
  [673, 0, [[733, 4], [742, 4], [746, 4, [[783, 8]]], [796, 4]]]
]);
var $$css4 = {
  hash: "s-413vZPMk7oiT",
  code: "\n    .svelte-select.s-413vZPMk7oiT {\n        /* deprecating camelCase custom props in favour of kebab-case for v5 */\n        --borderRadius: var(--border-radius);\n        --clearSelectColor: var(--clear-select-color);\n        --clearSelectWidth: var(--clear-select-width);\n        --disabledBackground: var(--disabled-background);\n        --disabledBorderColor: var(--disabled-border-color);\n        --disabledColor: var(--disabled-color);\n        --disabledPlaceholderColor: var(--disabled-placeholder-color);\n        --disabledPlaceholderOpacity: var(--disabled-placeholder-opacity);\n        --errorBackground: var(--error-background);\n        --errorBorder: var(--error-border);\n        --groupItemPaddingLeft: var(--group-item-padding-left);\n        --groupTitleColor: var(--group-title-color);\n        --groupTitleFontSize: var(--group-title-font-size);\n        --groupTitleFontWeight: var(--group-title-font-weight);\n        --groupTitlePadding: var(--group-title-padding);\n        --groupTitleTextTransform: var(--group-title-text-transform);\n        --groupTitleBorderColor: var(--group-title-border-color);\n        --groupTitleBorderWidth: var(--group-title-border-width);\n        --groupTitleBorderStyle: var(--group-title-border-style);\n        --indicatorColor: var(--chevron-color);\n        --indicatorHeight: var(--chevron-height);\n        --indicatorWidth: var(--chevron-width);\n        --inputColor: var(--input-color);\n        --inputLeft: var(--input-left);\n        --inputLetterSpacing: var(--input-letter-spacing);\n        --inputMargin: var(--input-margin);\n        --inputPadding: var(--input-padding);\n        --itemActiveBackground: var(--item-active-background);\n        --itemColor: var(--item-color);\n        --itemFirstBorderRadius: var(--item-first-border-radius);\n        --itemHoverBG: var(--item-hover-bg);\n        --itemHoverColor: var(--item-hover-color);\n        --itemIsActiveBG: var(--item-is-active-bg);\n        --itemIsActiveColor: var(--item-is-active-color);\n        --itemIsNotSelectableColor: var(--item-is-not-selectable-color);\n        --itemPadding: var(--item-padding);\n        --listBackground: var(--list-background);\n        --listBorder: var(--list-border);\n        --listBorderRadius: var(--list-border-radius);\n        --listEmptyColor: var(--list-empty-color);\n        --listEmptyPadding: var(--list-empty-padding);\n        --listEmptyTextAlign: var(--list-empty-text-align);\n        --listMaxHeight: var(--list-max-height);\n        --listPosition: var(--list-position);\n        --listShadow: var(--list-shadow);\n        --listZIndex: var(--list-z-index);\n        --multiItemBG: var(--multi-item-bg);\n        --multiItemBorderRadius: var(--multi-item-border-radius);\n        --multiItemDisabledHoverBg: var(--multi-item-disabled-hover-bg);\n        --multiItemDisabledHoverColor: var(--multi-item-disabled-hover-color);\n        --multiItemHeight: var(--multi-item-height);\n        --multiItemMargin: var(--multi-item-margin);\n        --multiItemPadding: var(--multi-item-padding);\n        --multiSelectInputMargin: var(--multi-select-input-margin);\n        --multiSelectInputPadding: var(--multi-select-input-padding);\n        --multiSelectPadding: var(--multi-select-padding);\n        --placeholderColor: var(--placeholder-color);\n        --placeholderOpacity: var(--placeholder-opacity);\n        --selectedItemPadding: var(--selected-item-padding);\n        --spinnerColor: var(--spinner-color);\n        --spinnerHeight: var(--spinner-height);\n        --spinnerWidth: var(--spinner-width);\n\n        --internal-padding: 0 0 0 16px;\n\n        border: var(--border, 1px solid #d8dbdf);\n        border-radius: var(--border-radius, 6px);\n        min-height: var(--height, 42px);\n        position: relative;\n        display: flex;\n        align-items: stretch;\n        padding: var(--padding, var(--internal-padding));\n        background: var(--background, #fff);\n        margin: var(--margin, 0);\n        width: var(--width, 100%);\n        font-size: var(--font-size, 16px);\n        max-height: var(--max-height);\n    }\n\n    .s-413vZPMk7oiT {\n        box-sizing: var(--box-sizing, border-box);\n    }\n\n    .svelte-select.s-413vZPMk7oiT:hover {\n        border: var(--border-hover, 1px solid #b2b8bf);\n    }\n\n    .value-container.s-413vZPMk7oiT {\n        display: flex;\n        flex: 1 1 0%;\n        flex-wrap: wrap;\n        align-items: center;\n        gap: 5px 10px;\n        padding: var(--value-container-padding, 5px 0);\n        position: relative;\n        overflow: var(--value-container-overflow, hidden);\n        align-self: stretch;\n    }\n\n    .prepend.s-413vZPMk7oiT,\n    .indicators.s-413vZPMk7oiT {\n        display: flex;\n        flex-shrink: 0;\n        align-items: center;\n    }\n\n    .indicators.s-413vZPMk7oiT {\n        position: var(--indicators-position);\n        top: var(--indicators-top);\n        right: var(--indicators-right);\n        bottom: var(--indicators-bottom);\n    }\n\n    input.s-413vZPMk7oiT {\n        position: absolute;\n        cursor: default;\n        border: none;\n        color: var(--input-color, var(--item-color));\n        padding: var(--input-padding, 0);\n        letter-spacing: var(--input-letter-spacing, inherit);\n        margin: var(--input-margin, 0);\n        min-width: 10px;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        background: transparent;\n        font-size: var(--font-size, 16px);\n    }\n\n    .s-413vZPMk7oiT:not(.multi) > .value-container:where(.s-413vZPMk7oiT) > input:where(.s-413vZPMk7oiT) {\n        width: 100%;\n        height: 100%;\n    }\n\n    input.s-413vZPMk7oiT::placeholder {\n        color: var(--placeholder-color, #78848f);\n        opacity: var(--placeholder-opacity, 1);\n    }\n\n    input.s-413vZPMk7oiT:focus {\n        outline: none;\n    }\n\n    .svelte-select.focused.s-413vZPMk7oiT {\n        border: var(--border-focused, 1px solid #006fe8);\n        border-radius: var(--border-radius-focused, var(--border-radius, 6px));\n    }\n\n    .disabled.s-413vZPMk7oiT {\n        background: var(--disabled-background, #ebedef);\n        border-color: var(--disabled-border-color, #ebedef);\n        color: var(--disabled-color, #c1c6cc);\n    }\n\n    .disabled.s-413vZPMk7oiT input:where(.s-413vZPMk7oiT)::placeholder {\n        color: var(--disabled-placeholder-color, #c1c6cc);\n        opacity: var(--disabled-placeholder-opacity, 1);\n    }\n\n    .selected-item.s-413vZPMk7oiT {\n        position: relative;\n        overflow: var(--selected-item-overflow, hidden);\n        padding: var(--selected-item-padding, 0 20px 0 0);\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        color: var(--selected-item-color, inherit);\n        font-size: var(--font-size, 16px);\n    }\n\n    .multi.s-413vZPMk7oiT .selected-item:where(.s-413vZPMk7oiT) {\n        position: absolute;\n        line-height: var(--height, 42px);\n        height: var(--height, 42px);\n    }\n\n    .selected-item.s-413vZPMk7oiT:focus {\n        outline: none;\n    }\n\n    .hide-selected-item.s-413vZPMk7oiT {\n        opacity: 0;\n    }\n\n    .icon.s-413vZPMk7oiT {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .clear-select.s-413vZPMk7oiT {\n        all: unset;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: var(--clear-select-width, 40px);\n        height: var(--clear-select-height, 100%);\n        color: var(--clear-select-color, var(--icons-color));\n        margin: var(--clear-select-margin, 0);\n        pointer-events: all;\n        flex-shrink: 0;\n    }\n\n    .clear-select.s-413vZPMk7oiT:focus {\n        outline: var(--clear-select-focus-outline, 1px solid #006fe8);\n    }\n\n    .loading.s-413vZPMk7oiT {\n        width: var(--loading-width, 40px);\n        height: var(--loading-height);\n        color: var(--loading-color, var(--icons-color));\n        margin: var(--loading--margin, 0);\n        flex-shrink: 0;\n    }\n\n    .chevron.s-413vZPMk7oiT {\n        width: var(--chevron-width, 40px);\n        height: var(--chevron-height, 40px);\n        background: var(--chevron-background, transparent);\n        pointer-events: var(--chevron-pointer-events, none);\n        color: var(--chevron-color, var(--icons-color));\n        border: var(--chevron-border, 0 0 0 1px solid #d8dbdf);\n        flex-shrink: 0;\n    }\n\n    .multi.s-413vZPMk7oiT {\n        padding: var(--multi-select-padding, var(--internal-padding));\n    }\n\n    .multi.s-413vZPMk7oiT input:where(.s-413vZPMk7oiT) {\n        padding: var(--multi-select-input-padding, 0);\n        position: relative;\n        margin: var(--multi-select-input-margin, 5px 0);\n        flex: 1 1 40px;\n    }\n\n    .svelte-select.error.s-413vZPMk7oiT {\n        border: var(--error-border, 1px solid #ff2d55);\n        background: var(--error-background, #fff);\n    }\n\n    .a11y-text.s-413vZPMk7oiT {\n        z-index: 9999;\n        border: 0px;\n        clip: rect(1px, 1px, 1px, 1px);\n        height: 1px;\n        width: 1px;\n        position: absolute;\n        overflow: hidden;\n        padding: 0px;\n        white-space: nowrap;\n    }\n\n    .multi-item.s-413vZPMk7oiT {\n        background: var(--multi-item-bg, #ebedef);\n        margin: var(--multi-item-margin, 0);\n        outline: var(--multi-item-outline, 1px solid #ddd);\n        border-radius: var(--multi-item-border-radius, 4px);\n        height: var(--multi-item-height, 25px);\n        line-height: var(--multi-item-height, 25px);\n        display: flex;\n        cursor: default;\n        padding: var(--multi-item-padding, 0 5px);\n        overflow: hidden;\n        gap: var(--multi-item-gap, 4px);\n        outline-offset: -1px;\n        max-width: var(--multi-max-width, none);\n        color: var(--multi-item-color, var(--item-color));\n    }\n\n    .multi-item.disabled.s-413vZPMk7oiT:hover {\n        background: var(--multi-item-disabled-hover-bg, #ebedef);\n        color: var(--multi-item-disabled-hover-color, #c1c6cc);\n    }\n\n    .multi-item-text.s-413vZPMk7oiT {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n    }\n\n    .multi-item-clear.s-413vZPMk7oiT {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        --clear-icon-color: var(--multi-item-clear-icon-color, #000);\n    }\n\n    .multi-item.active.s-413vZPMk7oiT {\n        outline: var(--multi-item-active-outline, 1px solid #006fe8);\n    }\n\n    .svelte-select-list.s-413vZPMk7oiT {\n        box-shadow: var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));\n        border-radius: var(--list-border-radius, 4px);\n        max-height: var(--list-max-height, 252px);\n        overflow-y: auto;\n        background: var(--list-background, #fff);\n        position: var(--list-position, absolute);\n        z-index: var(--list-z-index, 2);\n        border: var(--list-border);\n    }\n\n    .prefloat.s-413vZPMk7oiT {\n        opacity: 0;\n        pointer-events: none;\n    }\n\n    .list-group-title.s-413vZPMk7oiT {\n        color: var(--group-title-color, #8f8f8f);\n        cursor: default;\n        font-size: var(--group-title-font-size, 16px);\n        font-weight: var(--group-title-font-weight, 600);\n        height: var(--height, 42px);\n        line-height: var(--height, 42px);\n        padding: var(--group-title-padding, 0 20px);\n        text-overflow: ellipsis;\n        overflow-x: hidden;\n        white-space: nowrap;\n        text-transform: var(--group-title-text-transform, uppercase);\n        border-width: var(--group-title-border-width, medium);\n        border-style: var(--group-title-border-style, none);\n        border-color: var(--group-title-border-color, color);\n    }\n\n    .empty.s-413vZPMk7oiT {\n        text-align: var(--list-empty-text-align, center);\n        padding: var(--list-empty-padding, 20px 0);\n        color: var(--list-empty-color, #78848f);\n    }\n\n    .item.s-413vZPMk7oiT {\n        cursor: default;\n        height: var(--item-height, var(--height, 42px));\n        line-height: var(--item-line-height, var(--height, 42px));\n        padding: var(--item-padding, 0 20px);\n        color: var(--item-color, inherit);\n        text-overflow: ellipsis;\n        overflow: hidden;\n        white-space: nowrap;\n        transition: var(--item-transition, all 0.2s);\n        align-items: center;\n        width: 100%;\n    }\n\n    .item.group-item.s-413vZPMk7oiT {\n        padding-left: var(--group-item-padding-left, 40px);\n    }\n\n    .item.s-413vZPMk7oiT:active {\n        background: var(--item-active-background, #b9daff);\n    }\n\n    .item.active.s-413vZPMk7oiT {\n        background: var(--item-is-active-bg, #007aff);\n        color: var(--item-is-active-color, #fff);\n    }\n\n    .item.first.s-413vZPMk7oiT {\n        border-radius: var(--item-first-border-radius, 4px 4px 0 0);\n    }\n\n    .item.hover.s-413vZPMk7oiT:not(.active) {\n        background: var(--item-hover-bg, #e7f2ff);\n        color: var(--item-hover-color, inherit);\n    }\n\n    .item.not-selectable.s-413vZPMk7oiT,\n    .item.hover.item.not-selectable.s-413vZPMk7oiT,\n    .item.active.item.not-selectable.s-413vZPMk7oiT,\n    .item.not-selectable.s-413vZPMk7oiT:active {\n        color: var(--item-is-not-selectable-color, #999);\n        background: transparent;\n    }\n\n    .required.s-413vZPMk7oiT {\n        opacity: 0;\n        z-index: -1;\n        position: absolute;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0LnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2VsZWN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGJlZm9yZVVwZGF0ZSwgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbkRlc3Ryb3ksIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB7IG9mZnNldCwgZmxpcCwgc2hpZnQgfSBmcm9tICdzdmVsdGUtZmxvYXRpbmctdWkvZG9tJztcbiAgICBpbXBvcnQgeyBjcmVhdGVGbG9hdGluZ0FjdGlvbnMgfSBmcm9tICdzdmVsdGUtZmxvYXRpbmctdWknO1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIGltcG9ydCBfZmlsdGVyIGZyb20gJy4vZmlsdGVyJztcbiAgICBpbXBvcnQgX2dldEl0ZW1zIGZyb20gJy4vZ2V0LWl0ZW1zJztcblxuICAgIGltcG9ydCBDaGV2cm9uSWNvbiBmcm9tICcuL0NoZXZyb25JY29uLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IENsZWFySWNvbiBmcm9tICcuL0NsZWFySWNvbi5zdmVsdGUnO1xuICAgIGltcG9ydCBMb2FkaW5nSWNvbiBmcm9tICcuL0xvYWRpbmdJY29uLnN2ZWx0ZSc7XG5cbiAgICBleHBvcnQgbGV0IGp1c3RWYWx1ZSA9IG51bGw7IC8vIHJlYWQtb25seVxuXG4gICAgZXhwb3J0IGxldCBmaWx0ZXIgPSBfZmlsdGVyO1xuICAgIGV4cG9ydCBsZXQgZ2V0SXRlbXMgPSBfZ2V0SXRlbXM7XG5cbiAgICBleHBvcnQgbGV0IGlkID0gbnVsbDtcbiAgICBleHBvcnQgbGV0IG5hbWUgPSBudWxsO1xuICAgIGV4cG9ydCBsZXQgY29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgIGV4cG9ydCBsZXQgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgZXhwb3J0IGxldCBtdWx0aXBsZSA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgbXVsdGlGdWxsSXRlbUNsZWFyYWJsZSA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IGZvY3VzZWQgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBleHBvcnQgbGV0IGZpbHRlclRleHQgPSAnJztcbiAgICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyID0gJ1BsZWFzZSBzZWxlY3QnO1xuICAgIGV4cG9ydCBsZXQgcGxhY2Vob2xkZXJBbHdheXNTaG93ID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBpdGVtcyA9IG51bGw7XG4gICAgZXhwb3J0IGxldCBsYWJlbCA9ICdsYWJlbCc7XG4gICAgZXhwb3J0IGxldCBpdGVtRmlsdGVyID0gKGxhYmVsLCBmaWx0ZXJUZXh0LCBvcHRpb24pID0+IGAke2xhYmVsfWAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJUZXh0LnRvTG93ZXJDYXNlKCkpO1xuICAgIGV4cG9ydCBsZXQgZ3JvdXBCeSA9IHVuZGVmaW5lZDtcbiAgICBleHBvcnQgbGV0IGdyb3VwRmlsdGVyID0gKGdyb3VwcykgPT4gZ3JvdXBzO1xuICAgIGV4cG9ydCBsZXQgZ3JvdXBIZWFkZXJTZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBpdGVtSWQgPSAndmFsdWUnO1xuICAgIGV4cG9ydCBsZXQgbG9hZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgZXhwb3J0IGxldCBjb250YWluZXJTdHlsZXMgPSAnJztcbiAgICBleHBvcnQgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBmaWx0ZXJTZWxlY3RlZEl0ZW1zID0gdHJ1ZTtcbiAgICBleHBvcnQgbGV0IHJlcXVpcmVkID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBjbG9zZUxpc3RPbkNoYW5nZSA9IHRydWU7XG4gICAgZXhwb3J0IGxldCBjbGVhckZpbHRlclRleHRPbkJsdXIgPSB0cnVlO1xuXG4gICAgZXhwb3J0IGxldCBjcmVhdGVHcm91cEhlYWRlckl0ZW0gPSAoZ3JvdXBWYWx1ZSwgaXRlbSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGdyb3VwVmFsdWUsXG4gICAgICAgICAgICBbbGFiZWxdOiBncm91cFZhbHVlLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBleHBvcnQgY29uc3QgZ2V0RmlsdGVyZWRJdGVtcyA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkSXRlbXM7XG4gICAgfTtcblxuICAgIGV4cG9ydCBsZXQgc2VhcmNoYWJsZSA9IHRydWU7XG4gICAgZXhwb3J0IGxldCBpbnB1dFN0eWxlcyA9ICcnO1xuICAgIGV4cG9ydCBsZXQgY2xlYXJhYmxlID0gdHJ1ZTtcbiAgICBleHBvcnQgbGV0IGxvYWRpbmcgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IGxpc3RPcGVuID0gZmFsc2U7XG5cbiAgICBsZXQgdGltZW91dDtcbiAgICBleHBvcnQgbGV0IGRlYm91bmNlID0gKGZuLCB3YWl0ID0gMSkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCB3YWl0KTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGxldCBkZWJvdW5jZVdhaXQgPSAzMDA7XG4gICAgZXhwb3J0IGxldCBoaWRlRW1wdHlTdGF0ZSA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgaW5wdXRBdHRyaWJ1dGVzID0ge307XG4gICAgZXhwb3J0IGxldCBsaXN0QXV0b1dpZHRoID0gdHJ1ZTtcbiAgICBleHBvcnQgbGV0IHNob3dDaGV2cm9uID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBsaXN0T2Zmc2V0ID0gNTtcbiAgICBleHBvcnQgbGV0IGhvdmVySXRlbUluZGV4ID0gMDtcbiAgICBleHBvcnQgbGV0IGZsb2F0aW5nQ29uZmlnID0ge307XG5cbiAgICBleHBvcnQgeyBjb250YWluZXJDbGFzc2VzIGFzIGNsYXNzIH07XG5cbiAgICBsZXQgY29udGFpbmVyQ2xhc3NlcyA9ICcnO1xuICAgIGxldCBhY3RpdmVWYWx1ZTtcbiAgICBsZXQgcHJldl92YWx1ZTtcbiAgICBsZXQgcHJldl9maWx0ZXJUZXh0O1xuICAgIGxldCBwcmV2X211bHRpcGxlO1xuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IChpdGVtcyB8fCBbXSkuZmluZCgoaXRlbSkgPT4gaXRlbVtpdGVtSWRdID09PSB2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZW0gfHwge1xuICAgICAgICAgICAgICAgIFtpdGVtSWRdOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogdmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG11bHRpcGxlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKChpdGVtKSA9PiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnID8geyB2YWx1ZTogaXRlbSwgbGFiZWw6IGl0ZW0gfSA6IGl0ZW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBfaW5wdXRBdHRyaWJ1dGVzO1xuICAgIGZ1bmN0aW9uIGFzc2lnbklucHV0QXR0cmlidXRlcygpIHtcbiAgICAgICAgX2lucHV0QXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdub25lJyxcbiAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgICAgICAgICAgIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbiAgICAgICAgICAgICAgICBzcGVsbGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWJpbmRleDogMCxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0QXR0cmlidXRlc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgX2lucHV0QXR0cmlidXRlc1snaWQnXSA9IGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWFyY2hhYmxlKSB7XG4gICAgICAgICAgICBfaW5wdXRBdHRyaWJ1dGVzWydyZWFkb25seSddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRTdHJpbmdJdGVtc1RvT2JqZWN0cyhfaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIF9pdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBgJHtpdGVtfWAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJHcm91cGVkSXRlbXMoX2l0ZW1zKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwVmFsdWVzID0gW107XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuXG4gICAgICAgIF9pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncm91cFZhbHVlID0gZ3JvdXBCeShpdGVtKTtcblxuICAgICAgICAgICAgaWYgKCFncm91cFZhbHVlcy5pbmNsdWRlcyhncm91cFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGdyb3VwVmFsdWVzLnB1c2goZ3JvdXBWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2dyb3VwVmFsdWVdID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBWYWx1ZV0ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY3JlYXRlR3JvdXBIZWFkZXJJdGVtKGdyb3VwVmFsdWUsIGl0ZW0pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGdyb3VwVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBIZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogZ3JvdXBIZWFkZXJTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3Vwc1tncm91cFZhbHVlXS5wdXNoKE9iamVjdC5hc3NpZ24oeyBncm91cEl0ZW06ICEhZ3JvdXBWYWx1ZSB9LCBpdGVtKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHNvcnRlZEdyb3VwZWRJdGVtcyA9IFtdO1xuXG4gICAgICAgIGdyb3VwRmlsdGVyKGdyb3VwVmFsdWVzKS5mb3JFYWNoKChncm91cFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2dyb3VwVmFsdWVdKSBzb3J0ZWRHcm91cGVkSXRlbXMucHVzaCguLi5ncm91cHNbZ3JvdXBWYWx1ZV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc29ydGVkR3JvdXBlZEl0ZW1zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoU2VsZWN0ZWRJdGVtKCkge1xuICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChKU09OLnN0cmluZ2lmeSh2YWx1ZSkgIT09IEpTT04uc3RyaW5naWZ5KHByZXZfdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVmFsdWVGb3JEdXBsaWNhdGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ2lucHV0JywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJldl92YWx1ZSB8fCBKU09OLnN0cmluZ2lmeSh2YWx1ZVtpdGVtSWRdKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldl92YWx1ZVtpdGVtSWRdKSkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ2lucHV0JywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBNdWx0aSgpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFsuLi52YWx1ZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwU2luZ2xlKCkge1xuICAgICAgICBpZiAodmFsdWUpIHZhbHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICAkOiBpZiAoKGl0ZW1zLCB2YWx1ZSkpIHNldFZhbHVlKCk7XG4gICAgJDogaWYgKGlucHV0QXR0cmlidXRlcyB8fCAhc2VhcmNoYWJsZSkgYXNzaWduSW5wdXRBdHRyaWJ1dGVzKCk7XG4gICAgJDogaWYgKG11bHRpcGxlKSBzZXR1cE11bHRpKCk7XG4gICAgJDogaWYgKHByZXZfbXVsdGlwbGUgJiYgIW11bHRpcGxlKSBzZXR1cFNpbmdsZSgpO1xuICAgICQ6IGlmIChtdWx0aXBsZSAmJiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAxKSBjaGVja1ZhbHVlRm9yRHVwbGljYXRlcygpO1xuICAgICQ6IGlmICh2YWx1ZSkgZGlzcGF0Y2hTZWxlY3RlZEl0ZW0oKTtcbiAgICAkOiBpZiAoIXZhbHVlICYmIG11bHRpcGxlICYmIHByZXZfdmFsdWUpIGRpc3BhdGNoKCdpbnB1dCcsIHZhbHVlKTtcbiAgICAkOiBpZiAoIWZvY3VzZWQgJiYgaW5wdXQpIGNsb3NlTGlzdCgpO1xuICAgICQ6IGlmIChmaWx0ZXJUZXh0ICE9PSBwcmV2X2ZpbHRlclRleHQpIHNldHVwRmlsdGVyVGV4dCgpO1xuICAgICQ6IGlmICghbXVsdGlwbGUgJiYgbGlzdE9wZW4gJiYgdmFsdWUgJiYgZmlsdGVyZWRJdGVtcykgc2V0VmFsdWVJbmRleEFzSG92ZXJJbmRleCgpO1xuICAgICQ6IGRpc3BhdGNoSG92ZXIoaG92ZXJJdGVtSW5kZXgpO1xuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWVJbmRleEFzSG92ZXJJbmRleCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVJbmRleCA9IGZpbHRlcmVkSXRlbXMuZmluZEluZGV4KChpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaVtpdGVtSWRdID09PSB2YWx1ZVtpdGVtSWRdO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaGVja0hvdmVyU2VsZWN0YWJsZSh2YWx1ZUluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEhvdmVyKGkpIHtcbiAgICAgICAgZGlzcGF0Y2goJ2hvdmVySXRlbScsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrSG92ZXJTZWxlY3RhYmxlKHN0YXJ0aW5nSW5kZXggPSAwLCBpZ25vcmVHcm91cCkge1xuICAgICAgICBob3Zlckl0ZW1JbmRleCA9IHN0YXJ0aW5nSW5kZXggPCAwID8gMCA6IHN0YXJ0aW5nSW5kZXg7XG4gICAgICAgIGlmICghaWdub3JlR3JvdXAgJiYgZ3JvdXBCeSAmJiBmaWx0ZXJlZEl0ZW1zW2hvdmVySXRlbUluZGV4XSAmJiAhZmlsdGVyZWRJdGVtc1tob3Zlckl0ZW1JbmRleF0uc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgc2V0SG92ZXJJbmRleCgxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwRmlsdGVyVGV4dCgpIHtcbiAgICAgICAgaWYgKCFsb2FkT3B0aW9ucyAmJiBmaWx0ZXJUZXh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChsb2FkT3B0aW9ucykge1xuICAgICAgICAgICAgZGVib3VuY2UoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBnZXRJdGVtcyh7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAgICAgICAgICAgICBsb2FkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY29udmVydFN0cmluZ0l0ZW1zVG9PYmplY3RzLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nID0gcmVzLmxvYWRpbmc7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RPcGVuID0gbGlzdE9wZW4gPyByZXMubGlzdE9wZW4gOiBmaWx0ZXJUZXh0Lmxlbmd0aCA+IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWQgPSBsaXN0T3BlbiAmJiByZXMuZm9jdXNlZDtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBncm91cEJ5ID8gZmlsdGVyR3JvdXBlZEl0ZW1zKHJlcy5maWx0ZXJlZEl0ZW1zKSA6IHJlcy5maWx0ZXJlZEl0ZW1zO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBkZWJvdW5jZVdhaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdE9wZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgICQ6IGhhc1ZhbHVlID0gbXVsdGlwbGUgPyB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwIDogdmFsdWU7XG4gICAgJDogaGlkZVNlbGVjdGVkSXRlbSA9IGhhc1ZhbHVlICYmIGZpbHRlclRleHQubGVuZ3RoID4gMDtcbiAgICAkOiBzaG93Q2xlYXIgPSBoYXNWYWx1ZSAmJiBjbGVhcmFibGUgJiYgIWRpc2FibGVkICYmICFsb2FkaW5nO1xuICAgICQ6IHBsYWNlaG9sZGVyVGV4dCA9XG4gICAgICAgIHBsYWNlaG9sZGVyQWx3YXlzU2hvdyAmJiBtdWx0aXBsZVxuICAgICAgICAgICAgPyBwbGFjZWhvbGRlclxuICAgICAgICAgICAgOiBtdWx0aXBsZSAmJiB2YWx1ZT8ubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IHBsYWNlaG9sZGVyO1xuICAgICQ6IGFyaWFTZWxlY3Rpb24gPSB2YWx1ZSA/IGhhbmRsZUFyaWFTZWxlY3Rpb24obXVsdGlwbGUpIDogJyc7XG4gICAgJDogYXJpYUNvbnRleHQgPSBoYW5kbGVBcmlhQ29udGVudCh7IGZpbHRlcmVkSXRlbXMsIGhvdmVySXRlbUluZGV4LCBmb2N1c2VkLCBsaXN0T3BlbiB9KTtcbiAgICAkOiB1cGRhdGVWYWx1ZURpc3BsYXkoaXRlbXMpO1xuICAgICQ6IGp1c3RWYWx1ZSA9IGNvbXB1dGVKdXN0VmFsdWUobXVsdGlwbGUsIHZhbHVlLCBpdGVtSWQpO1xuICAgICQ6IGlmICghbXVsdGlwbGUgJiYgcHJldl92YWx1ZSAmJiAhdmFsdWUpIGRpc3BhdGNoKCdpbnB1dCcsIHZhbHVlKTtcbiAgICAkOiBmaWx0ZXJlZEl0ZW1zID0gZmlsdGVyKHtcbiAgICAgICAgbG9hZE9wdGlvbnMsXG4gICAgICAgIGZpbHRlclRleHQsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgZ3JvdXBCeSxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZpbHRlclNlbGVjdGVkSXRlbXMsXG4gICAgICAgIGl0ZW1GaWx0ZXIsXG4gICAgICAgIGNvbnZlcnRTdHJpbmdJdGVtc1RvT2JqZWN0cyxcbiAgICAgICAgZmlsdGVyR3JvdXBlZEl0ZW1zLFxuICAgIH0pO1xuICAgICQ6IGlmIChsaXN0T3BlbiAmJiBmaWx0ZXJlZEl0ZW1zICYmICFtdWx0aXBsZSAmJiAhdmFsdWUpIGNoZWNrSG92ZXJTZWxlY3RhYmxlKCk7XG4gICAgJDogaGFuZGxlRmlsdGVyRXZlbnQoZmlsdGVyZWRJdGVtcyk7XG4gICAgJDogaWYgKGNvbnRhaW5lciAmJiBmbG9hdGluZ0NvbmZpZykgZmxvYXRpbmdVcGRhdGUoT2JqZWN0LmFzc2lnbihfZmxvYXRpbmdDb25maWcsIGZsb2F0aW5nQ29uZmlnKSk7XG4gICAgJDogbGlzdERvbSA9ICEhbGlzdDtcbiAgICAkOiBsaXN0TW91bnRlZChsaXN0LCBsaXN0T3Blbik7XG4gICAgJDogaWYgKGxpc3RPcGVuICYmIGNvbnRhaW5lciAmJiBsaXN0KSBzZXRMaXN0V2lkdGgoKTtcbiAgICAkOiBzY3JvbGxUb0hvdmVySXRlbSA9IGhvdmVySXRlbUluZGV4O1xuICAgICQ6IGlmIChsaXN0T3BlbiAmJiBtdWx0aXBsZSkgaG92ZXJJdGVtSW5kZXggPSAwO1xuICAgICQ6IGlmIChpbnB1dCAmJiBsaXN0T3BlbiAmJiAhZm9jdXNlZCkgaGFuZGxlRm9jdXMoKTtcbiAgICAkOiBpZiAoZmlsdGVyVGV4dCkgaG92ZXJJdGVtSW5kZXggPSAwO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlRmlsdGVyRXZlbnQoaXRlbXMpIHtcbiAgICAgICAgaWYgKGxpc3RPcGVuKSBkaXNwYXRjaCgnZmlsdGVyJywgaXRlbXMpO1xuICAgIH1cblxuICAgIGJlZm9yZVVwZGF0ZShhc3luYyAoKSA9PiB7XG4gICAgICAgIHByZXZfdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcHJldl9maWx0ZXJUZXh0ID0gZmlsdGVyVGV4dDtcbiAgICAgICAgcHJldl9tdWx0aXBsZSA9IG11bHRpcGxlO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUp1c3RWYWx1ZSgpIHtcbiAgICAgICAgaWYgKG11bHRpcGxlKSByZXR1cm4gdmFsdWUgPyB2YWx1ZS5tYXAoKGl0ZW0pID0+IGl0ZW1baXRlbUlkXSkgOiBudWxsO1xuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZVtpdGVtSWRdIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tWYWx1ZUZvckR1cGxpY2F0ZXMoKSB7XG4gICAgICAgIGxldCBub0R1cGxpY2F0ZXMgPSB0cnVlO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVzID0gW107XG5cbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaWRzLmluY2x1ZGVzKHZhbFtpdGVtSWRdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZHMucHVzaCh2YWxbaXRlbUlkXSk7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZVZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9EdXBsaWNhdGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghbm9EdXBsaWNhdGVzKSB2YWx1ZSA9IHVuaXF1ZVZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9EdXBsaWNhdGVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJdGVtKHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgbWF0Y2hUbyA9IHNlbGVjdGlvbiA/IHNlbGVjdGlvbltpdGVtSWRdIDogdmFsdWVbaXRlbUlkXTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW1baXRlbUlkXSA9PT0gbWF0Y2hUbyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlVmFsdWVEaXNwbGF5KGl0ZW1zKSB7XG4gICAgICAgIGlmICghaXRlbXMgfHwgaXRlbXMubGVuZ3RoID09PSAwIHx8IGl0ZW1zLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JykpIHJldHVybjtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAobXVsdGlwbGUgPyB2YWx1ZS5zb21lKChzZWxlY3Rpb24pID0+ICFzZWxlY3Rpb24gfHwgIXNlbGVjdGlvbltpdGVtSWRdKSA6ICF2YWx1ZVtpdGVtSWRdKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoKHNlbGVjdGlvbikgPT4gZmluZEl0ZW0oc2VsZWN0aW9uKSB8fCBzZWxlY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBmaW5kSXRlbSgpIHx8IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTXVsdGlJdGVtQ2xlYXIoaSkge1xuICAgICAgICBjb25zdCBpdGVtVG9SZW1vdmUgPSB2YWx1ZVtpXTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGl0ZW1Ub1JlbW92ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGF0Y2goJ2NsZWFyJywgaXRlbVRvUmVtb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKCFmb2N1c2VkKSByZXR1cm47XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGNsb3NlTGlzdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChsaXN0T3Blbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRJdGVtcy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3Zlckl0ZW0gPSBmaWx0ZXJlZEl0ZW1zW2hvdmVySXRlbUluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgIW11bHRpcGxlICYmIHZhbHVlW2l0ZW1JZF0gPT09IGhvdmVySXRlbVtpdGVtSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUxpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2VsZWN0KGZpbHRlcmVkSXRlbXNbaG92ZXJJdGVtSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobGlzdE9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SG92ZXJJbmRleCgxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0T3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdmVySW5kZXgoLTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUYWInOlxuICAgICAgICAgICAgICAgIGlmIChsaXN0T3BlbiAmJiBmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsdWUgJiYgdmFsdWVbaXRlbUlkXSA9PT0gZmlsdGVyZWRJdGVtc1tob3Zlckl0ZW1JbmRleF1baXRlbUlkXSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3NlTGlzdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2VsZWN0KGZpbHRlcmVkSXRlbXNbaG92ZXJJdGVtSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgICAgICAgICAgIGlmICghbXVsdGlwbGUgfHwgZmlsdGVyVGV4dC5sZW5ndGggPiAwKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUgJiYgdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNdWx0aUl0ZW1DbGVhcihhY3RpdmVWYWx1ZSAhPT0gdW5kZWZpbmVkID8gYWN0aXZlVmFsdWUgOiB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVZhbHVlID09PSAwIHx8IGFjdGl2ZVZhbHVlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVWYWx1ZSA9IHZhbHVlLmxlbmd0aCA+IGFjdGl2ZVZhbHVlID8gYWN0aXZlVmFsdWUgLSAxIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8ICFtdWx0aXBsZSB8fCBmaWx0ZXJUZXh0Lmxlbmd0aCA+IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVWYWx1ZSA9IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPiBhY3RpdmVWYWx1ZSAmJiBhY3RpdmVWYWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVWYWx1ZSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUgfHwgIW11bHRpcGxlIHx8IGZpbHRlclRleHQubGVuZ3RoID4gMCB8fCBhY3RpdmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVZhbHVlID09PSB2YWx1ZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aXZlVmFsdWUgPCB2YWx1ZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVZhbHVlICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXMoZSkge1xuICAgICAgICBpZiAoZm9jdXNlZCAmJiBpbnB1dCA9PT0gZG9jdW1lbnQ/LmFjdGl2ZUVsZW1lbnQpIHJldHVybjtcbiAgICAgICAgaWYgKGUpIGRpc3BhdGNoKCdmb2N1cycsIGUpO1xuICAgICAgICBpbnB1dD8uZm9jdXMoKTtcbiAgICAgICAgZm9jdXNlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQmx1cihlKSB7XG4gICAgICAgIGlmIChpc1Njcm9sbGluZykgcmV0dXJuO1xuICAgICAgICBpZiAobGlzdE9wZW4gfHwgZm9jdXNlZCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ2JsdXInLCBlKTtcbiAgICAgICAgICAgIGNsb3NlTGlzdCgpO1xuICAgICAgICAgICAgZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYWN0aXZlVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpbnB1dD8uYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZmlsdGVyVGV4dC5sZW5ndGggPiAwKSByZXR1cm4gbGlzdE9wZW4gPSB0cnVlO1xuICAgICAgICBsaXN0T3BlbiA9ICFsaXN0T3BlbjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaGFuZGxlQ2xlYXIoKSB7XG4gICAgICAgIGRpc3BhdGNoKCdjbGVhcicsIHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNsb3NlTGlzdCgpO1xuICAgICAgICBoYW5kbGVGb2N1cygpO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAobGlzdE9wZW4pIGZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZm9jdXNlZCAmJiBpbnB1dCkgaW5wdXQuZm9jdXMoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGl0ZW1TZWxlY3RlZChzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgZmlsdGVyVGV4dCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIHNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLmdyb3VwSGVhZGVyICYmICFpdGVtLnNlbGVjdGFibGUpIHJldHVybjtcbiAgICAgICAgICAgIHZhbHVlID0gbXVsdGlwbGUgPyAodmFsdWUgPyB2YWx1ZS5jb25jYXQoW2l0ZW1dKSA6IFtpdGVtXSkgOiAodmFsdWUgPSBpdGVtKTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlTGlzdE9uQ2hhbmdlKSBjbG9zZUxpc3QoKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnY2hhbmdlJywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdzZWxlY3QnLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZUxpc3QoKSB7XG4gICAgICAgIGlmIChjbGVhckZpbHRlclRleHRPbkJsdXIpIHtcbiAgICAgICAgICAgIGZpbHRlclRleHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBsaXN0T3BlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cG9ydCBsZXQgYXJpYVZhbHVlcyA9ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgcmV0dXJuIGBPcHRpb24gJHt2YWx1ZXN9LCBzZWxlY3RlZC5gO1xuICAgIH07XG5cbiAgICBleHBvcnQgbGV0IGFyaWFMaXN0T3BlbiA9IChsYWJlbCwgY291bnQpID0+IHtcbiAgICAgICAgcmV0dXJuIGBZb3UgYXJlIGN1cnJlbnRseSBmb2N1c2VkIG9uIG9wdGlvbiAke2xhYmVsfS4gVGhlcmUgYXJlICR7Y291bnR9IHJlc3VsdHMgYXZhaWxhYmxlLmA7XG4gICAgfTtcblxuICAgIGV4cG9ydCBsZXQgYXJpYUZvY3VzZWQgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBgU2VsZWN0IGlzIGZvY3VzZWQsIHR5cGUgdG8gcmVmaW5lIGxpc3QsIHByZXNzIGRvd24gdG8gb3BlbiB0aGUgbWVudS5gO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVBcmlhU2VsZWN0aW9uKF9tdWx0aXBsZSkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKF9tdWx0aXBsZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHZhbHVlLm1hcCgodikgPT4gdltsYWJlbF0pLmpvaW4oJywgJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHZhbHVlW2xhYmVsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmlhVmFsdWVzKHNlbGVjdGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVBcmlhQ29udGVudCgpIHtcbiAgICAgICAgaWYgKCFmaWx0ZXJlZEl0ZW1zIHx8IGZpbHRlcmVkSXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICAgIGxldCBfaXRlbSA9IGZpbHRlcmVkSXRlbXNbaG92ZXJJdGVtSW5kZXhdO1xuICAgICAgICBpZiAobGlzdE9wZW4gJiYgX2l0ZW0pIHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IGZpbHRlcmVkSXRlbXMgPyBmaWx0ZXJlZEl0ZW1zLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICByZXR1cm4gYXJpYUxpc3RPcGVuKF9pdGVtW2xhYmVsXSwgY291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFyaWFGb2N1c2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbGlzdCA9IG51bGw7XG5cbiAgICBsZXQgaXNTY3JvbGxpbmdUaW1lcjtcbiAgICBmdW5jdGlvbiBoYW5kbGVMaXN0U2Nyb2xsKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaXNTY3JvbGxpbmdUaW1lcik7XG4gICAgICAgIGlzU2Nyb2xsaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGlmICghbGlzdE9wZW4gJiYgIWZvY3VzZWQgJiYgY29udGFpbmVyICYmICFjb250YWluZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSAmJiAhbGlzdD8uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgaGFuZGxlQmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgbGlzdD8ucmVtb3ZlKCk7XG4gICAgfSk7XG5cbiAgICBsZXQgaXNTY3JvbGxpbmcgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVNlbGVjdChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSB8fCBpdGVtLnNlbGVjdGFibGUgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGl0ZW1TZWxlY3RlZChpdGVtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVIb3ZlcihpKSB7XG4gICAgICAgIGlmIChpc1Njcm9sbGluZykgcmV0dXJuO1xuICAgICAgICBob3Zlckl0ZW1JbmRleCA9IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlSXRlbUNsaWNrKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBpdGVtLCBpIH0gPSBhcmdzO1xuICAgICAgICBpZiAoaXRlbT8uc2VsZWN0YWJsZSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgaWYgKHZhbHVlICYmICFtdWx0aXBsZSAmJiB2YWx1ZVtpdGVtSWRdID09PSBpdGVtW2l0ZW1JZF0pIHJldHVybiBjbG9zZUxpc3QoKTtcbiAgICAgICAgaWYgKGlzSXRlbVNlbGVjdGFibGUoaXRlbSkpIHtcbiAgICAgICAgICAgIGhvdmVySXRlbUluZGV4ID0gaTtcbiAgICAgICAgICAgIGhhbmRsZVNlbGVjdChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEhvdmVySW5kZXgoaW5jcmVtZW50KSB7XG4gICAgICAgIGxldCBzZWxlY3RhYmxlRmlsdGVyZWRJdGVtcyA9IGZpbHRlcmVkSXRlbXMuZmlsdGVyKFxuICAgICAgICAgICAgKGl0ZW0pID0+ICFPYmplY3QuaGFzT3duKGl0ZW0sICdzZWxlY3RhYmxlJykgfHwgaXRlbS5zZWxlY3RhYmxlID09PSB0cnVlXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGFibGVGaWx0ZXJlZEl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIChob3Zlckl0ZW1JbmRleCA9IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluY3JlbWVudCA+IDAgJiYgaG92ZXJJdGVtSW5kZXggPT09IGZpbHRlcmVkSXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaG92ZXJJdGVtSW5kZXggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGluY3JlbWVudCA8IDAgJiYgaG92ZXJJdGVtSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGhvdmVySXRlbUluZGV4ID0gZmlsdGVyZWRJdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG92ZXJJdGVtSW5kZXggPSBob3Zlckl0ZW1JbmRleCArIGluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhvdmVyID0gZmlsdGVyZWRJdGVtc1tob3Zlckl0ZW1JbmRleF07XG5cbiAgICAgICAgaWYgKGhvdmVyICYmIGhvdmVyLnNlbGVjdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ID09PSAxIHx8IGluY3JlbWVudCA9PT0gLTEpIHNldEhvdmVySW5kZXgoaW5jcmVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSXRlbUFjdGl2ZShpdGVtLCB2YWx1ZSwgaXRlbUlkKSB7XG4gICAgICAgIGlmIChtdWx0aXBsZSkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbaXRlbUlkXSA9PT0gaXRlbVtpdGVtSWRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSXRlbUZpcnN0KGl0ZW1JbmRleCkge1xuICAgICAgICByZXR1cm4gaXRlbUluZGV4ID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSXRlbVNlbGVjdGFibGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gKGl0ZW0uZ3JvdXBIZWFkZXIgJiYgaXRlbS5zZWxlY3RhYmxlKSB8fCBpdGVtLnNlbGVjdGFibGUgfHwgIWl0ZW0uaGFzT3duUHJvcGVydHkoJ3NlbGVjdGFibGUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVTY3JvbGwgPSBzY3JvbGxBY3Rpb247XG4gICAgY29uc3QgaG92ZXJTY3JvbGwgPSBzY3JvbGxBY3Rpb247XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxBY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXBkYXRlKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5zY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTGlzdFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6ICdhdXRvJywgYmxvY2s6ICduZWFyZXN0JyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldExpc3RXaWR0aCgpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsaXN0LnN0eWxlLndpZHRoID0gbGlzdEF1dG9XaWR0aCA/IHdpZHRoICsgJ3B4JyA6ICdhdXRvJztcbiAgICB9XG5cbiAgICBsZXQgX2Zsb2F0aW5nQ29uZmlnID0ge1xuICAgICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgbWlkZGxld2FyZTogW29mZnNldChsaXN0T2Zmc2V0KSwgZmxpcCgpLCBzaGlmdCgpXSxcbiAgICAgICAgYXV0b1VwZGF0ZTogZmFsc2UsXG4gICAgfTtcblxuICAgIGNvbnN0IFtmbG9hdGluZ1JlZiwgZmxvYXRpbmdDb250ZW50LCBmbG9hdGluZ1VwZGF0ZV0gPSBjcmVhdGVGbG9hdGluZ0FjdGlvbnMoX2Zsb2F0aW5nQ29uZmlnKTtcblxuICAgICQ6IGlmIChjb250YWluZXIgJiYgZmxvYXRpbmdDb25maWc/LmF1dG9VcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfZmxvYXRpbmdDb25maWcuYXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHByZWZsb2F0ID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBsaXN0TW91bnRlZChsaXN0LCBsaXN0T3Blbikge1xuICAgICAgICBpZiAoIWxpc3QgfHwgIWxpc3RPcGVuKSByZXR1cm4gKHByZWZsb2F0ID0gdHJ1ZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcHJlZmxvYXQgPSBmYWxzZTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6d2luZG93IG9uOmNsaWNrPXtoYW5kbGVDbGlja091dHNpZGV9IG9uOmtleWRvd249e2hhbmRsZUtleURvd259IC8+XG5cbjxkaXZcbiAgICBjbGFzcz1cInN2ZWx0ZS1zZWxlY3Qge2NvbnRhaW5lckNsYXNzZXN9XCJcbiAgICBjbGFzczptdWx0aT17bXVsdGlwbGV9XG4gICAgY2xhc3M6ZGlzYWJsZWRcbiAgICBjbGFzczpmb2N1c2VkXG4gICAgY2xhc3M6bGlzdC1vcGVuPXtsaXN0T3Blbn1cbiAgICBjbGFzczpzaG93LWNoZXZyb249e3Nob3dDaGV2cm9ufVxuICAgIGNsYXNzOmVycm9yPXtoYXNFcnJvcn1cbiAgICBzdHlsZT17Y29udGFpbmVyU3R5bGVzfVxuICAgIG9uOnBvaW50ZXJ1cHxwcmV2ZW50RGVmYXVsdD17aGFuZGxlQ2xpY2t9XG4gICAgYmluZDp0aGlzPXtjb250YWluZXJ9XG4gICAgdXNlOmZsb2F0aW5nUmVmXG4gICAgcm9sZT1cIm5vbmVcIj5cbiAgICB7I2lmIGxpc3RPcGVufVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICB1c2U6ZmxvYXRpbmdDb250ZW50XG4gICAgICAgICAgICBiaW5kOnRoaXM9e2xpc3R9XG4gICAgICAgICAgICBjbGFzcz1cInN2ZWx0ZS1zZWxlY3QtbGlzdFwiXG4gICAgICAgICAgICBjbGFzczpwcmVmbG9hdFxuICAgICAgICAgICAgb246c2Nyb2xsPXtoYW5kbGVMaXN0U2Nyb2xsfVxuICAgICAgICAgICAgb246cG9pbnRlcnVwfHByZXZlbnREZWZhdWx0fHN0b3BQcm9wYWdhdGlvblxuICAgICAgICAgICAgb246bW91c2Vkb3dufHByZXZlbnREZWZhdWx0fHN0b3BQcm9wYWdhdGlvblxuXHRcdFx0cm9sZT1cIm5vbmVcIj5cbiAgICAgICAgICAgIHsjaWYgJCRzbG90c1snbGlzdC1wcmVwZW5kJ119PHNsb3QgbmFtZT1cImxpc3QtcHJlcGVuZFwiIC8+ey9pZn1cbiAgICAgICAgICAgIHsjaWYgJCRzbG90cy5saXN0fTxzbG90IG5hbWU9XCJsaXN0XCIge2ZpbHRlcmVkSXRlbXN9IC8+XG4gICAgICAgICAgICB7OmVsc2UgaWYgZmlsdGVyZWRJdGVtcy5sZW5ndGggPiAwfVxuICAgICAgICAgICAgICAgIHsjZWFjaCBmaWx0ZXJlZEl0ZW1zIGFzIGl0ZW0sIGl9XG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOm1vdXNlb3Zlcj17KCkgPT4gaGFuZGxlSG92ZXIoaSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpmb2N1cz17KCkgPT4gaGFuZGxlSG92ZXIoaSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGlja3xzdG9wUHJvcGFnYXRpb249eygpID0+IGhhbmRsZUl0ZW1DbGljayh7IGl0ZW0sIGkgfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjprZXlkb3dufHByZXZlbnREZWZhdWx0fHN0b3BQcm9wYWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJsaXN0LWl0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwibm9uZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZTphY3RpdmVTY3JvbGw9e3sgc2Nyb2xsOiBpc0l0ZW1BY3RpdmUoaXRlbSwgdmFsdWUsIGl0ZW1JZCksIGxpc3REb20gfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2U6aG92ZXJTY3JvbGw9e3sgc2Nyb2xsOiBzY3JvbGxUb0hvdmVySXRlbSA9PT0gaSwgbGlzdERvbSB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6bGlzdC1ncm91cC10aXRsZT17aXRlbS5ncm91cEhlYWRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczphY3RpdmU9e2lzSXRlbUFjdGl2ZShpdGVtLCB2YWx1ZSwgaXRlbUlkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczpmaXJzdD17aXNJdGVtRmlyc3QoaSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6aG92ZXI9e2hvdmVySXRlbUluZGV4ID09PSBpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOmdyb3VwLWl0ZW09e2l0ZW0uZ3JvdXBJdGVtfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOm5vdC1zZWxlY3RhYmxlPXtpdGVtPy5zZWxlY3RhYmxlID09PSBmYWxzZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cIml0ZW1cIiB7aXRlbX0gaW5kZXg9e2l9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXRlbT8uW2xhYmVsXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgezplbHNlIGlmICFoaWRlRW1wdHlTdGF0ZX1cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiZW1wdHlcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVtcHR5XCI+Tm8gb3B0aW9uczwvZGl2PlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7I2lmICQkc2xvdHNbJ2xpc3QtYXBwZW5kJ119PHNsb3QgbmFtZT1cImxpc3QtYXBwZW5kXCIgLz57L2lmfVxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuXG4gICAgPHNwYW4gYXJpYS1saXZlPVwicG9saXRlXCIgYXJpYS1hdG9taWM9XCJmYWxzZVwiIGFyaWEtcmVsZXZhbnQ9XCJhZGRpdGlvbnMgdGV4dFwiIGNsYXNzPVwiYTExeS10ZXh0XCI+XG4gICAgICAgIHsjaWYgZm9jdXNlZH1cbiAgICAgICAgICAgIDxzcGFuIGlkPVwiYXJpYS1zZWxlY3Rpb25cIj57YXJpYVNlbGVjdGlvbn08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBpZD1cImFyaWEtY29udGV4dFwiPlxuICAgICAgICAgICAgICAgIHthcmlhQ29udGV4dH1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgey9pZn1cbiAgICA8L3NwYW4+XG5cbiAgICA8ZGl2IGNsYXNzPVwicHJlcGVuZFwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwicHJlcGVuZFwiIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidmFsdWUtY29udGFpbmVyXCI+XG4gICAgICAgIHsjaWYgaGFzVmFsdWV9XG4gICAgICAgICAgICB7I2lmIG11bHRpcGxlfVxuICAgICAgICAgICAgICAgIHsjZWFjaCB2YWx1ZSBhcyBpdGVtLCBpfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm11bHRpLWl0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6YWN0aXZlPXthY3RpdmVWYWx1ZSA9PT0gaX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOmRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGlja3xwcmV2ZW50RGVmYXVsdD17KCkgPT4gKG11bHRpRnVsbEl0ZW1DbGVhcmFibGUgPyBoYW5kbGVNdWx0aUl0ZW1DbGVhcihpKSA6IHt9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOmtleWRvd258cHJldmVudERlZmF1bHR8c3RvcFByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwibm9uZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtdWx0aS1pdGVtLXRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwic2VsZWN0aW9uXCIgc2VsZWN0aW9uPXtpdGVtfSBpbmRleD17aX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpdGVtW2xhYmVsXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgIWRpc2FibGVkICYmICFtdWx0aUZ1bGxJdGVtQ2xlYXJhYmxlICYmIENsZWFySWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwibXVsdGktaXRlbS1jbGVhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOnBvaW50ZXJ1cHxwcmV2ZW50RGVmYXVsdHxzdG9wUHJvcGFnYXRpb249eygpID0+IGhhbmRsZU11bHRpSXRlbUNsZWFyKGkpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cIm11bHRpLWNsZWFyLWljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxDbGVhckljb24gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWxlY3RlZC1pdGVtXCIgY2xhc3M6aGlkZS1zZWxlY3RlZC1pdGVtPXtoaWRlU2VsZWN0ZWRJdGVtfT5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cInNlbGVjdGlvblwiIHNlbGVjdGlvbj17dmFsdWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbHVlW2xhYmVsXX1cbiAgICAgICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9pZn1cblxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIG9uOmtleWRvd249e2hhbmRsZUtleURvd259XG4gICAgICAgICAgICBvbjpibHVyPXtoYW5kbGVCbHVyfVxuICAgICAgICAgICAgb246Zm9jdXM9e2hhbmRsZUZvY3VzfVxuICAgICAgICAgICAgcmVhZE9ubHk9eyFzZWFyY2hhYmxlfVxuICAgICAgICAgICAgey4uLl9pbnB1dEF0dHJpYnV0ZXN9XG4gICAgICAgICAgICBiaW5kOnRoaXM9e2lucHV0fVxuICAgICAgICAgICAgYmluZDp2YWx1ZT17ZmlsdGVyVGV4dH1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlclRleHR9XG4gICAgICAgICAgICBzdHlsZT17aW5wdXRTdHlsZXN9XG4gICAgICAgICAgICB7ZGlzYWJsZWR9IC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5kaWNhdG9yc1wiPlxuICAgICAgICB7I2lmIGxvYWRpbmd9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaWNvbiBsb2FkaW5nXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImxvYWRpbmctaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICA8TG9hZGluZ0ljb24gLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgey9pZn1cblxuICAgICAgICB7I2lmIHNob3dDbGVhcn1cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiaWNvbiBjbGVhci1zZWxlY3RcIiBvbjpjbGljaz17aGFuZGxlQ2xlYXJ9PlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJjbGVhci1pY29uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxDbGVhckljb24gLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgey9pZn1cblxuICAgICAgICB7I2lmIHNob3dDaGV2cm9ufVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImljb24gY2hldnJvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJjaGV2cm9uLWljb25cIiB7bGlzdE9wZW59PlxuICAgICAgICAgICAgICAgICAgICA8Q2hldnJvbkljb24gLz5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cblxuICAgIDxzbG90IG5hbWU9XCJpbnB1dC1oaWRkZW5cIiB7dmFsdWV9PlxuICAgICAgICA8aW5wdXQge25hbWV9IHR5cGU9XCJoaWRkZW5cIiB2YWx1ZT17dmFsdWUgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBudWxsfSAvPlxuICAgIDwvc2xvdD5cblxuICAgIHsjaWYgcmVxdWlyZWQgJiYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApfVxuICAgICAgICA8c2xvdCBuYW1lPVwicmVxdWlyZWRcIiB7dmFsdWV9PlxuICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cInJlcXVpcmVkXCIgcmVxdWlyZWQgdGFiaW5kZXg9XCItMVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG4gICAgICAgIDwvc2xvdD5cbiAgICB7L2lmfVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAuc3ZlbHRlLXNlbGVjdCB7XG4gICAgICAgIC8qIGRlcHJlY2F0aW5nIGNhbWVsQ2FzZSBjdXN0b20gcHJvcHMgaW4gZmF2b3VyIG9mIGtlYmFiLWNhc2UgZm9yIHY1ICovXG4gICAgICAgIC0tYm9yZGVyUmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzKTtcbiAgICAgICAgLS1jbGVhclNlbGVjdENvbG9yOiB2YXIoLS1jbGVhci1zZWxlY3QtY29sb3IpO1xuICAgICAgICAtLWNsZWFyU2VsZWN0V2lkdGg6IHZhcigtLWNsZWFyLXNlbGVjdC13aWR0aCk7XG4gICAgICAgIC0tZGlzYWJsZWRCYWNrZ3JvdW5kOiB2YXIoLS1kaXNhYmxlZC1iYWNrZ3JvdW5kKTtcbiAgICAgICAgLS1kaXNhYmxlZEJvcmRlckNvbG9yOiB2YXIoLS1kaXNhYmxlZC1ib3JkZXItY29sb3IpO1xuICAgICAgICAtLWRpc2FibGVkQ29sb3I6IHZhcigtLWRpc2FibGVkLWNvbG9yKTtcbiAgICAgICAgLS1kaXNhYmxlZFBsYWNlaG9sZGVyQ29sb3I6IHZhcigtLWRpc2FibGVkLXBsYWNlaG9sZGVyLWNvbG9yKTtcbiAgICAgICAgLS1kaXNhYmxlZFBsYWNlaG9sZGVyT3BhY2l0eTogdmFyKC0tZGlzYWJsZWQtcGxhY2Vob2xkZXItb3BhY2l0eSk7XG4gICAgICAgIC0tZXJyb3JCYWNrZ3JvdW5kOiB2YXIoLS1lcnJvci1iYWNrZ3JvdW5kKTtcbiAgICAgICAgLS1lcnJvckJvcmRlcjogdmFyKC0tZXJyb3ItYm9yZGVyKTtcbiAgICAgICAgLS1ncm91cEl0ZW1QYWRkaW5nTGVmdDogdmFyKC0tZ3JvdXAtaXRlbS1wYWRkaW5nLWxlZnQpO1xuICAgICAgICAtLWdyb3VwVGl0bGVDb2xvcjogdmFyKC0tZ3JvdXAtdGl0bGUtY29sb3IpO1xuICAgICAgICAtLWdyb3VwVGl0bGVGb250U2l6ZTogdmFyKC0tZ3JvdXAtdGl0bGUtZm9udC1zaXplKTtcbiAgICAgICAgLS1ncm91cFRpdGxlRm9udFdlaWdodDogdmFyKC0tZ3JvdXAtdGl0bGUtZm9udC13ZWlnaHQpO1xuICAgICAgICAtLWdyb3VwVGl0bGVQYWRkaW5nOiB2YXIoLS1ncm91cC10aXRsZS1wYWRkaW5nKTtcbiAgICAgICAgLS1ncm91cFRpdGxlVGV4dFRyYW5zZm9ybTogdmFyKC0tZ3JvdXAtdGl0bGUtdGV4dC10cmFuc2Zvcm0pO1xuICAgICAgICAtLWdyb3VwVGl0bGVCb3JkZXJDb2xvcjogdmFyKC0tZ3JvdXAtdGl0bGUtYm9yZGVyLWNvbG9yKTtcbiAgICAgICAgLS1ncm91cFRpdGxlQm9yZGVyV2lkdGg6IHZhcigtLWdyb3VwLXRpdGxlLWJvcmRlci13aWR0aCk7XG4gICAgICAgIC0tZ3JvdXBUaXRsZUJvcmRlclN0eWxlOiB2YXIoLS1ncm91cC10aXRsZS1ib3JkZXItc3R5bGUpO1xuICAgICAgICAtLWluZGljYXRvckNvbG9yOiB2YXIoLS1jaGV2cm9uLWNvbG9yKTtcbiAgICAgICAgLS1pbmRpY2F0b3JIZWlnaHQ6IHZhcigtLWNoZXZyb24taGVpZ2h0KTtcbiAgICAgICAgLS1pbmRpY2F0b3JXaWR0aDogdmFyKC0tY2hldnJvbi13aWR0aCk7XG4gICAgICAgIC0taW5wdXRDb2xvcjogdmFyKC0taW5wdXQtY29sb3IpO1xuICAgICAgICAtLWlucHV0TGVmdDogdmFyKC0taW5wdXQtbGVmdCk7XG4gICAgICAgIC0taW5wdXRMZXR0ZXJTcGFjaW5nOiB2YXIoLS1pbnB1dC1sZXR0ZXItc3BhY2luZyk7XG4gICAgICAgIC0taW5wdXRNYXJnaW46IHZhcigtLWlucHV0LW1hcmdpbik7XG4gICAgICAgIC0taW5wdXRQYWRkaW5nOiB2YXIoLS1pbnB1dC1wYWRkaW5nKTtcbiAgICAgICAgLS1pdGVtQWN0aXZlQmFja2dyb3VuZDogdmFyKC0taXRlbS1hY3RpdmUtYmFja2dyb3VuZCk7XG4gICAgICAgIC0taXRlbUNvbG9yOiB2YXIoLS1pdGVtLWNvbG9yKTtcbiAgICAgICAgLS1pdGVtRmlyc3RCb3JkZXJSYWRpdXM6IHZhcigtLWl0ZW0tZmlyc3QtYm9yZGVyLXJhZGl1cyk7XG4gICAgICAgIC0taXRlbUhvdmVyQkc6IHZhcigtLWl0ZW0taG92ZXItYmcpO1xuICAgICAgICAtLWl0ZW1Ib3ZlckNvbG9yOiB2YXIoLS1pdGVtLWhvdmVyLWNvbG9yKTtcbiAgICAgICAgLS1pdGVtSXNBY3RpdmVCRzogdmFyKC0taXRlbS1pcy1hY3RpdmUtYmcpO1xuICAgICAgICAtLWl0ZW1Jc0FjdGl2ZUNvbG9yOiB2YXIoLS1pdGVtLWlzLWFjdGl2ZS1jb2xvcik7XG4gICAgICAgIC0taXRlbUlzTm90U2VsZWN0YWJsZUNvbG9yOiB2YXIoLS1pdGVtLWlzLW5vdC1zZWxlY3RhYmxlLWNvbG9yKTtcbiAgICAgICAgLS1pdGVtUGFkZGluZzogdmFyKC0taXRlbS1wYWRkaW5nKTtcbiAgICAgICAgLS1saXN0QmFja2dyb3VuZDogdmFyKC0tbGlzdC1iYWNrZ3JvdW5kKTtcbiAgICAgICAgLS1saXN0Qm9yZGVyOiB2YXIoLS1saXN0LWJvcmRlcik7XG4gICAgICAgIC0tbGlzdEJvcmRlclJhZGl1czogdmFyKC0tbGlzdC1ib3JkZXItcmFkaXVzKTtcbiAgICAgICAgLS1saXN0RW1wdHlDb2xvcjogdmFyKC0tbGlzdC1lbXB0eS1jb2xvcik7XG4gICAgICAgIC0tbGlzdEVtcHR5UGFkZGluZzogdmFyKC0tbGlzdC1lbXB0eS1wYWRkaW5nKTtcbiAgICAgICAgLS1saXN0RW1wdHlUZXh0QWxpZ246IHZhcigtLWxpc3QtZW1wdHktdGV4dC1hbGlnbik7XG4gICAgICAgIC0tbGlzdE1heEhlaWdodDogdmFyKC0tbGlzdC1tYXgtaGVpZ2h0KTtcbiAgICAgICAgLS1saXN0UG9zaXRpb246IHZhcigtLWxpc3QtcG9zaXRpb24pO1xuICAgICAgICAtLWxpc3RTaGFkb3c6IHZhcigtLWxpc3Qtc2hhZG93KTtcbiAgICAgICAgLS1saXN0WkluZGV4OiB2YXIoLS1saXN0LXotaW5kZXgpO1xuICAgICAgICAtLW11bHRpSXRlbUJHOiB2YXIoLS1tdWx0aS1pdGVtLWJnKTtcbiAgICAgICAgLS1tdWx0aUl0ZW1Cb3JkZXJSYWRpdXM6IHZhcigtLW11bHRpLWl0ZW0tYm9yZGVyLXJhZGl1cyk7XG4gICAgICAgIC0tbXVsdGlJdGVtRGlzYWJsZWRIb3ZlckJnOiB2YXIoLS1tdWx0aS1pdGVtLWRpc2FibGVkLWhvdmVyLWJnKTtcbiAgICAgICAgLS1tdWx0aUl0ZW1EaXNhYmxlZEhvdmVyQ29sb3I6IHZhcigtLW11bHRpLWl0ZW0tZGlzYWJsZWQtaG92ZXItY29sb3IpO1xuICAgICAgICAtLW11bHRpSXRlbUhlaWdodDogdmFyKC0tbXVsdGktaXRlbS1oZWlnaHQpO1xuICAgICAgICAtLW11bHRpSXRlbU1hcmdpbjogdmFyKC0tbXVsdGktaXRlbS1tYXJnaW4pO1xuICAgICAgICAtLW11bHRpSXRlbVBhZGRpbmc6IHZhcigtLW11bHRpLWl0ZW0tcGFkZGluZyk7XG4gICAgICAgIC0tbXVsdGlTZWxlY3RJbnB1dE1hcmdpbjogdmFyKC0tbXVsdGktc2VsZWN0LWlucHV0LW1hcmdpbik7XG4gICAgICAgIC0tbXVsdGlTZWxlY3RJbnB1dFBhZGRpbmc6IHZhcigtLW11bHRpLXNlbGVjdC1pbnB1dC1wYWRkaW5nKTtcbiAgICAgICAgLS1tdWx0aVNlbGVjdFBhZGRpbmc6IHZhcigtLW11bHRpLXNlbGVjdC1wYWRkaW5nKTtcbiAgICAgICAgLS1wbGFjZWhvbGRlckNvbG9yOiB2YXIoLS1wbGFjZWhvbGRlci1jb2xvcik7XG4gICAgICAgIC0tcGxhY2Vob2xkZXJPcGFjaXR5OiB2YXIoLS1wbGFjZWhvbGRlci1vcGFjaXR5KTtcbiAgICAgICAgLS1zZWxlY3RlZEl0ZW1QYWRkaW5nOiB2YXIoLS1zZWxlY3RlZC1pdGVtLXBhZGRpbmcpO1xuICAgICAgICAtLXNwaW5uZXJDb2xvcjogdmFyKC0tc3Bpbm5lci1jb2xvcik7XG4gICAgICAgIC0tc3Bpbm5lckhlaWdodDogdmFyKC0tc3Bpbm5lci1oZWlnaHQpO1xuICAgICAgICAtLXNwaW5uZXJXaWR0aDogdmFyKC0tc3Bpbm5lci13aWR0aCk7XG5cbiAgICAgICAgLS1pbnRlcm5hbC1wYWRkaW5nOiAwIDAgMCAxNnB4O1xuXG4gICAgICAgIGJvcmRlcjogdmFyKC0tYm9yZGVyLCAxcHggc29saWQgI2Q4ZGJkZik7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMsIDZweCk7XG4gICAgICAgIG1pbi1oZWlnaHQ6IHZhcigtLWhlaWdodCwgNDJweCk7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgICAgIHBhZGRpbmc6IHZhcigtLXBhZGRpbmcsIHZhcigtLWludGVybmFsLXBhZGRpbmcpKTtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tYmFja2dyb3VuZCwgI2ZmZik7XG4gICAgICAgIG1hcmdpbjogdmFyKC0tbWFyZ2luLCAwKTtcbiAgICAgICAgd2lkdGg6IHZhcigtLXdpZHRoLCAxMDAlKTtcbiAgICAgICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUsIDE2cHgpO1xuICAgICAgICBtYXgtaGVpZ2h0OiB2YXIoLS1tYXgtaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAqIHtcbiAgICAgICAgYm94LXNpemluZzogdmFyKC0tYm94LXNpemluZywgYm9yZGVyLWJveCk7XG4gICAgfVxuXG4gICAgLnN2ZWx0ZS1zZWxlY3Q6aG92ZXIge1xuICAgICAgICBib3JkZXI6IHZhcigtLWJvcmRlci1ob3ZlciwgMXB4IHNvbGlkICNiMmI4YmYpO1xuICAgIH1cblxuICAgIC52YWx1ZS1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4OiAxIDEgMCU7XG4gICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgZ2FwOiA1cHggMTBweDtcbiAgICAgICAgcGFkZGluZzogdmFyKC0tdmFsdWUtY29udGFpbmVyLXBhZGRpbmcsIDVweCAwKTtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBvdmVyZmxvdzogdmFyKC0tdmFsdWUtY29udGFpbmVyLW92ZXJmbG93LCBoaWRkZW4pO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIH1cblxuICAgIC5wcmVwZW5kLFxuICAgIC5pbmRpY2F0b3JzIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgLmluZGljYXRvcnMge1xuICAgICAgICBwb3NpdGlvbjogdmFyKC0taW5kaWNhdG9ycy1wb3NpdGlvbik7XG4gICAgICAgIHRvcDogdmFyKC0taW5kaWNhdG9ycy10b3ApO1xuICAgICAgICByaWdodDogdmFyKC0taW5kaWNhdG9ycy1yaWdodCk7XG4gICAgICAgIGJvdHRvbTogdmFyKC0taW5kaWNhdG9ycy1ib3R0b20pO1xuICAgIH1cblxuICAgIGlucHV0IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY29sb3I6IHZhcigtLWlucHV0LWNvbG9yLCB2YXIoLS1pdGVtLWNvbG9yKSk7XG4gICAgICAgIHBhZGRpbmc6IHZhcigtLWlucHV0LXBhZGRpbmcsIDApO1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogdmFyKC0taW5wdXQtbGV0dGVyLXNwYWNpbmcsIGluaGVyaXQpO1xuICAgICAgICBtYXJnaW46IHZhcigtLWlucHV0LW1hcmdpbiwgMCk7XG4gICAgICAgIG1pbi13aWR0aDogMTBweDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgICAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUsIDE2cHgpO1xuICAgIH1cblxuICAgIDpub3QoLm11bHRpKSA+IC52YWx1ZS1jb250YWluZXIgPiBpbnB1dCB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuXG4gICAgaW5wdXQ6OnBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBsYWNlaG9sZGVyLWNvbG9yLCAjNzg4NDhmKTtcbiAgICAgICAgb3BhY2l0eTogdmFyKC0tcGxhY2Vob2xkZXItb3BhY2l0eSwgMSk7XG4gICAgfVxuXG4gICAgaW5wdXQ6Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgIH1cblxuICAgIC5zdmVsdGUtc2VsZWN0LmZvY3VzZWQge1xuICAgICAgICBib3JkZXI6IHZhcigtLWJvcmRlci1mb2N1c2VkLCAxcHggc29saWQgIzAwNmZlOCk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMtZm9jdXNlZCwgdmFyKC0tYm9yZGVyLXJhZGl1cywgNnB4KSk7XG4gICAgfVxuXG4gICAgLmRpc2FibGVkIHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tZGlzYWJsZWQtYmFja2dyb3VuZCwgI2ViZWRlZik7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZGlzYWJsZWQtYm9yZGVyLWNvbG9yLCAjZWJlZGVmKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWRpc2FibGVkLWNvbG9yLCAjYzFjNmNjKTtcbiAgICB9XG5cbiAgICAuZGlzYWJsZWQgaW5wdXQ6OnBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWRpc2FibGVkLXBsYWNlaG9sZGVyLWNvbG9yLCAjYzFjNmNjKTtcbiAgICAgICAgb3BhY2l0eTogdmFyKC0tZGlzYWJsZWQtcGxhY2Vob2xkZXItb3BhY2l0eSwgMSk7XG4gICAgfVxuXG4gICAgLnNlbGVjdGVkLWl0ZW0ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG92ZXJmbG93OiB2YXIoLS1zZWxlY3RlZC1pdGVtLW92ZXJmbG93LCBoaWRkZW4pO1xuICAgICAgICBwYWRkaW5nOiB2YXIoLS1zZWxlY3RlZC1pdGVtLXBhZGRpbmcsIDAgMjBweCAwIDApO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgY29sb3I6IHZhcigtLXNlbGVjdGVkLWl0ZW0tY29sb3IsIGluaGVyaXQpO1xuICAgICAgICBmb250LXNpemU6IHZhcigtLWZvbnQtc2l6ZSwgMTZweCk7XG4gICAgfVxuXG4gICAgLm11bHRpIC5zZWxlY3RlZC1pdGVtIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsaW5lLWhlaWdodDogdmFyKC0taGVpZ2h0LCA0MnB4KTtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1oZWlnaHQsIDQycHgpO1xuICAgIH1cblxuICAgIC5zZWxlY3RlZC1pdGVtOmZvY3VzIHtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG5cbiAgICAuaGlkZS1zZWxlY3RlZC1pdGVtIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5cbiAgICAuaWNvbiB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIH1cblxuICAgIC5jbGVhci1zZWxlY3Qge1xuICAgICAgICBhbGw6IHVuc2V0O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IHZhcigtLWNsZWFyLXNlbGVjdC13aWR0aCwgNDBweCk7XG4gICAgICAgIGhlaWdodDogdmFyKC0tY2xlYXItc2VsZWN0LWhlaWdodCwgMTAwJSk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1jbGVhci1zZWxlY3QtY29sb3IsIHZhcigtLWljb25zLWNvbG9yKSk7XG4gICAgICAgIG1hcmdpbjogdmFyKC0tY2xlYXItc2VsZWN0LW1hcmdpbiwgMCk7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIH1cblxuICAgIC5jbGVhci1zZWxlY3Q6Zm9jdXMge1xuICAgICAgICBvdXRsaW5lOiB2YXIoLS1jbGVhci1zZWxlY3QtZm9jdXMtb3V0bGluZSwgMXB4IHNvbGlkICMwMDZmZTgpO1xuICAgIH1cblxuICAgIC5sb2FkaW5nIHtcbiAgICAgICAgd2lkdGg6IHZhcigtLWxvYWRpbmctd2lkdGgsIDQwcHgpO1xuICAgICAgICBoZWlnaHQ6IHZhcigtLWxvYWRpbmctaGVpZ2h0KTtcbiAgICAgICAgY29sb3I6IHZhcigtLWxvYWRpbmctY29sb3IsIHZhcigtLWljb25zLWNvbG9yKSk7XG4gICAgICAgIG1hcmdpbjogdmFyKC0tbG9hZGluZy0tbWFyZ2luLCAwKTtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgfVxuXG4gICAgLmNoZXZyb24ge1xuICAgICAgICB3aWR0aDogdmFyKC0tY2hldnJvbi13aWR0aCwgNDBweCk7XG4gICAgICAgIGhlaWdodDogdmFyKC0tY2hldnJvbi1oZWlnaHQsIDQwcHgpO1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1jaGV2cm9uLWJhY2tncm91bmQsIHRyYW5zcGFyZW50KTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IHZhcigtLWNoZXZyb24tcG9pbnRlci1ldmVudHMsIG5vbmUpO1xuICAgICAgICBjb2xvcjogdmFyKC0tY2hldnJvbi1jb2xvciwgdmFyKC0taWNvbnMtY29sb3IpKTtcbiAgICAgICAgYm9yZGVyOiB2YXIoLS1jaGV2cm9uLWJvcmRlciwgMCAwIDAgMXB4IHNvbGlkICNkOGRiZGYpO1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICB9XG5cbiAgICAubXVsdGkge1xuICAgICAgICBwYWRkaW5nOiB2YXIoLS1tdWx0aS1zZWxlY3QtcGFkZGluZywgdmFyKC0taW50ZXJuYWwtcGFkZGluZykpO1xuICAgIH1cblxuICAgIC5tdWx0aSBpbnB1dCB7XG4gICAgICAgIHBhZGRpbmc6IHZhcigtLW11bHRpLXNlbGVjdC1pbnB1dC1wYWRkaW5nLCAwKTtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW46IHZhcigtLW11bHRpLXNlbGVjdC1pbnB1dC1tYXJnaW4sIDVweCAwKTtcbiAgICAgICAgZmxleDogMSAxIDQwcHg7XG4gICAgfVxuXG4gICAgLnN2ZWx0ZS1zZWxlY3QuZXJyb3Ige1xuICAgICAgICBib3JkZXI6IHZhcigtLWVycm9yLWJvcmRlciwgMXB4IHNvbGlkICNmZjJkNTUpO1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1lcnJvci1iYWNrZ3JvdW5kLCAjZmZmKTtcbiAgICB9XG5cbiAgICAuYTExeS10ZXh0IHtcbiAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgYm9yZGVyOiAwcHg7XG4gICAgICAgIGNsaXA6IHJlY3QoMXB4LCAxcHgsIDFweCwgMXB4KTtcbiAgICAgICAgaGVpZ2h0OiAxcHg7XG4gICAgICAgIHdpZHRoOiAxcHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcGFkZGluZzogMHB4O1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIH1cblxuICAgIC5tdWx0aS1pdGVtIHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbXVsdGktaXRlbS1iZywgI2ViZWRlZik7XG4gICAgICAgIG1hcmdpbjogdmFyKC0tbXVsdGktaXRlbS1tYXJnaW4sIDApO1xuICAgICAgICBvdXRsaW5lOiB2YXIoLS1tdWx0aS1pdGVtLW91dGxpbmUsIDFweCBzb2xpZCAjZGRkKTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tbXVsdGktaXRlbS1ib3JkZXItcmFkaXVzLCA0cHgpO1xuICAgICAgICBoZWlnaHQ6IHZhcigtLW11bHRpLWl0ZW0taGVpZ2h0LCAyNXB4KTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IHZhcigtLW11bHRpLWl0ZW0taGVpZ2h0LCAyNXB4KTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuICAgICAgICBwYWRkaW5nOiB2YXIoLS1tdWx0aS1pdGVtLXBhZGRpbmcsIDAgNXB4KTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgZ2FwOiB2YXIoLS1tdWx0aS1pdGVtLWdhcCwgNHB4KTtcbiAgICAgICAgb3V0bGluZS1vZmZzZXQ6IC0xcHg7XG4gICAgICAgIG1heC13aWR0aDogdmFyKC0tbXVsdGktbWF4LXdpZHRoLCBub25lKTtcbiAgICAgICAgY29sb3I6IHZhcigtLW11bHRpLWl0ZW0tY29sb3IsIHZhcigtLWl0ZW0tY29sb3IpKTtcbiAgICB9XG5cbiAgICAubXVsdGktaXRlbS5kaXNhYmxlZDpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLW11bHRpLWl0ZW0tZGlzYWJsZWQtaG92ZXItYmcsICNlYmVkZWYpO1xuICAgICAgICBjb2xvcjogdmFyKC0tbXVsdGktaXRlbS1kaXNhYmxlZC1ob3Zlci1jb2xvciwgI2MxYzZjYyk7XG4gICAgfVxuXG4gICAgLm11bHRpLWl0ZW0tdGV4dCB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIH1cblxuICAgIC5tdWx0aS1pdGVtLWNsZWFyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIC0tY2xlYXItaWNvbi1jb2xvcjogdmFyKC0tbXVsdGktaXRlbS1jbGVhci1pY29uLWNvbG9yLCAjMDAwKTtcbiAgICB9XG5cbiAgICAubXVsdGktaXRlbS5hY3RpdmUge1xuICAgICAgICBvdXRsaW5lOiB2YXIoLS1tdWx0aS1pdGVtLWFjdGl2ZS1vdXRsaW5lLCAxcHggc29saWQgIzAwNmZlOCk7XG4gICAgfVxuXG4gICAgLnN2ZWx0ZS1zZWxlY3QtbGlzdCB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLWxpc3Qtc2hhZG93LCAwIDJweCAzcHggMCByZ2JhKDQ0LCA2MiwgODAsIDAuMjQpKTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tbGlzdC1ib3JkZXItcmFkaXVzLCA0cHgpO1xuICAgICAgICBtYXgtaGVpZ2h0OiB2YXIoLS1saXN0LW1heC1oZWlnaHQsIDI1MnB4KTtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlzdC1iYWNrZ3JvdW5kLCAjZmZmKTtcbiAgICAgICAgcG9zaXRpb246IHZhcigtLWxpc3QtcG9zaXRpb24sIGFic29sdXRlKTtcbiAgICAgICAgei1pbmRleDogdmFyKC0tbGlzdC16LWluZGV4LCAyKTtcbiAgICAgICAgYm9yZGVyOiB2YXIoLS1saXN0LWJvcmRlcik7XG4gICAgfVxuXG4gICAgLnByZWZsb2F0IHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgfVxuXG4gICAgLmxpc3QtZ3JvdXAtdGl0bGUge1xuICAgICAgICBjb2xvcjogdmFyKC0tZ3JvdXAtdGl0bGUtY29sb3IsICM4ZjhmOGYpO1xuICAgICAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gICAgICAgIGZvbnQtc2l6ZTogdmFyKC0tZ3JvdXAtdGl0bGUtZm9udC1zaXplLCAxNnB4KTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IHZhcigtLWdyb3VwLXRpdGxlLWZvbnQtd2VpZ2h0LCA2MDApO1xuICAgICAgICBoZWlnaHQ6IHZhcigtLWhlaWdodCwgNDJweCk7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1oZWlnaHQsIDQycHgpO1xuICAgICAgICBwYWRkaW5nOiB2YXIoLS1ncm91cC10aXRsZS1wYWRkaW5nLCAwIDIwcHgpO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdmFyKC0tZ3JvdXAtdGl0bGUtdGV4dC10cmFuc2Zvcm0sIHVwcGVyY2FzZSk7XG4gICAgICAgIGJvcmRlci13aWR0aDogdmFyKC0tZ3JvdXAtdGl0bGUtYm9yZGVyLXdpZHRoLCBtZWRpdW0pO1xuICAgICAgICBib3JkZXItc3R5bGU6IHZhcigtLWdyb3VwLXRpdGxlLWJvcmRlci1zdHlsZSwgbm9uZSk7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZ3JvdXAtdGl0bGUtYm9yZGVyLWNvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgLmVtcHR5IHtcbiAgICAgICAgdGV4dC1hbGlnbjogdmFyKC0tbGlzdC1lbXB0eS10ZXh0LWFsaWduLCBjZW50ZXIpO1xuICAgICAgICBwYWRkaW5nOiB2YXIoLS1saXN0LWVtcHR5LXBhZGRpbmcsIDIwcHggMCk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1saXN0LWVtcHR5LWNvbG9yLCAjNzg4NDhmKTtcbiAgICB9XG5cbiAgICAuaXRlbSB7XG4gICAgICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1pdGVtLWhlaWdodCwgdmFyKC0taGVpZ2h0LCA0MnB4KSk7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1pdGVtLWxpbmUtaGVpZ2h0LCB2YXIoLS1oZWlnaHQsIDQycHgpKTtcbiAgICAgICAgcGFkZGluZzogdmFyKC0taXRlbS1wYWRkaW5nLCAwIDIwcHgpO1xuICAgICAgICBjb2xvcjogdmFyKC0taXRlbS1jb2xvciwgaW5oZXJpdCk7XG4gICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICB0cmFuc2l0aW9uOiB2YXIoLS1pdGVtLXRyYW5zaXRpb24sIGFsbCAwLjJzKTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLml0ZW0uZ3JvdXAtaXRlbSB7XG4gICAgICAgIHBhZGRpbmctbGVmdDogdmFyKC0tZ3JvdXAtaXRlbS1wYWRkaW5nLWxlZnQsIDQwcHgpO1xuICAgIH1cblxuICAgIC5pdGVtOmFjdGl2ZSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWl0ZW0tYWN0aXZlLWJhY2tncm91bmQsICNiOWRhZmYpO1xuICAgIH1cblxuICAgIC5pdGVtLmFjdGl2ZSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWl0ZW0taXMtYWN0aXZlLWJnLCAjMDA3YWZmKTtcbiAgICAgICAgY29sb3I6IHZhcigtLWl0ZW0taXMtYWN0aXZlLWNvbG9yLCAjZmZmKTtcbiAgICB9XG5cbiAgICAuaXRlbS5maXJzdCB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWl0ZW0tZmlyc3QtYm9yZGVyLXJhZGl1cywgNHB4IDRweCAwIDApO1xuICAgIH1cblxuICAgIC5pdGVtLmhvdmVyOm5vdCguYWN0aXZlKSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWl0ZW0taG92ZXItYmcsICNlN2YyZmYpO1xuICAgICAgICBjb2xvcjogdmFyKC0taXRlbS1ob3Zlci1jb2xvciwgaW5oZXJpdCk7XG4gICAgfVxuXG4gICAgLml0ZW0ubm90LXNlbGVjdGFibGUsXG4gICAgLml0ZW0uaG92ZXIuaXRlbS5ub3Qtc2VsZWN0YWJsZSxcbiAgICAuaXRlbS5hY3RpdmUuaXRlbS5ub3Qtc2VsZWN0YWJsZSxcbiAgICAuaXRlbS5ub3Qtc2VsZWN0YWJsZTphY3RpdmUge1xuICAgICAgICBjb2xvcjogdmFyKC0taXRlbS1pcy1ub3Qtc2VsZWN0YWJsZS1jb2xvciwgIzk5OSk7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIC5yZXF1aXJlZCB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHotaW5kZXg6IC0xO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGlu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 */"
};
function Select($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  push($$props, false, Select);
  append_styles($$anchor, $$css4);
  const hasValue = mutable_source();
  const hideSelectedItem = mutable_source();
  const showClear = mutable_source();
  const placeholderText = mutable_source();
  const ariaSelection = mutable_source();
  const ariaContext = mutable_source();
  const filteredItems = mutable_source();
  const listDom = mutable_source();
  const scrollToHoverItem = mutable_source();
  const dispatch = createEventDispatcher();
  let justValue = prop(
    $$props,
    "justValue",
    12,
    null
    // read-only
  );
  let filter2 = prop($$props, "filter", 8, filter);
  let getItems2 = prop($$props, "getItems", 8, getItems);
  let id = prop($$props, "id", 8, null);
  let name = prop($$props, "name", 8, null);
  let container = prop($$props, "container", 12, void 0);
  let input = prop($$props, "input", 12, void 0);
  let multiple = prop($$props, "multiple", 8, false);
  let multiFullItemClearable = prop($$props, "multiFullItemClearable", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let focused = prop($$props, "focused", 12, false);
  let value = prop($$props, "value", 12, null);
  let filterText = prop($$props, "filterText", 12, "");
  let placeholder = prop($$props, "placeholder", 8, "Please select");
  let placeholderAlwaysShow = prop($$props, "placeholderAlwaysShow", 8, false);
  let items = prop($$props, "items", 12, null);
  let label = prop($$props, "label", 8, "label");
  let itemFilter = prop($$props, "itemFilter", 8, (label2, filterText2, option) => `${label2}`.toLowerCase().includes(filterText2.toLowerCase()));
  let groupBy = prop($$props, "groupBy", 8, void 0);
  let groupFilter = prop($$props, "groupFilter", 8, (groups) => groups);
  let groupHeaderSelectable = prop($$props, "groupHeaderSelectable", 8, false);
  let itemId = prop($$props, "itemId", 8, "value");
  let loadOptions = prop($$props, "loadOptions", 8, void 0);
  let containerStyles = prop($$props, "containerStyles", 8, "");
  let hasError = prop($$props, "hasError", 8, false);
  let filterSelectedItems = prop($$props, "filterSelectedItems", 8, true);
  let required = prop($$props, "required", 8, false);
  let closeListOnChange = prop($$props, "closeListOnChange", 8, true);
  let clearFilterTextOnBlur = prop($$props, "clearFilterTextOnBlur", 8, true);
  let createGroupHeaderItem = prop($$props, "createGroupHeaderItem", 8, (groupValue, item) => {
    return { value: groupValue, [label()]: groupValue };
  });
  const getFilteredItems = () => {
    return get(filteredItems);
  };
  let searchable = prop($$props, "searchable", 8, true);
  let inputStyles = prop($$props, "inputStyles", 8, "");
  let clearable = prop($$props, "clearable", 8, true);
  let loading = prop($$props, "loading", 12, false);
  let listOpen = prop($$props, "listOpen", 12, false);
  let timeout;
  let debounce = prop($$props, "debounce", 8, (fn, wait = 1) => {
    clearTimeout(timeout);
    timeout = setTimeout(fn, wait);
  });
  let debounceWait = prop($$props, "debounceWait", 8, 300);
  let hideEmptyState = prop($$props, "hideEmptyState", 8, false);
  let inputAttributes = prop($$props, "inputAttributes", 24, () => ({}));
  let listAutoWidth = prop($$props, "listAutoWidth", 8, true);
  let showChevron = prop($$props, "showChevron", 8, false);
  let listOffset = prop($$props, "listOffset", 8, 5);
  let hoverItemIndex = prop($$props, "hoverItemIndex", 12, 0);
  let floatingConfig = prop($$props, "floatingConfig", 24, () => ({}));
  let containerClasses = prop($$props, "class", 8, "");
  let activeValue = mutable_source();
  let prev_value = mutable_source();
  let prev_filterText = mutable_source();
  let prev_multiple = mutable_source();
  function setValue() {
    if (strict_equals(typeof value(), "string")) {
      let item = (items() || []).find((item2) => strict_equals(item2[itemId()], value()));
      value(item || { [itemId()]: value(), label: value() });
    } else if (multiple() && Array.isArray(value()) && value().length > 0) {
      value(value().map((item) => strict_equals(typeof item, "string") ? { value: item, label: item } : item));
    }
  }
  let _inputAttributes = mutable_source();
  function assignInputAttributes() {
    set(_inputAttributes, Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      inputAttributes()
    ));
    if (id()) {
      mutate(_inputAttributes, get(_inputAttributes)["id"] = id());
    }
    if (!searchable()) {
      mutate(_inputAttributes, get(_inputAttributes)["readonly"] = true);
    }
  }
  function convertStringItemsToObjects(_items) {
    return _items.map((item, index2) => {
      return { index: index2, value: item, label: `${item}` };
    });
  }
  function filterGroupedItems(_items) {
    const groupValues = [];
    const groups = {};
    _items.forEach((item) => {
      const groupValue = groupBy()(item);
      if (!groupValues.includes(groupValue)) {
        groupValues.push(groupValue);
        groups[groupValue] = [];
        if (groupValue) {
          groups[groupValue].push(Object.assign(createGroupHeaderItem()(groupValue, item), {
            id: groupValue,
            groupHeader: true,
            selectable: groupHeaderSelectable()
          }));
        }
      }
      groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));
    });
    const sortedGroupedItems = [];
    groupFilter()(groupValues).forEach((groupValue) => {
      if (groups[groupValue]) sortedGroupedItems.push(...groups[groupValue]);
    });
    return sortedGroupedItems;
  }
  function dispatchSelectedItem() {
    if (multiple()) {
      if (strict_equals(JSON.stringify(value()), JSON.stringify(get(prev_value)), false)) {
        if (checkValueForDuplicates()) {
          dispatch("input", value());
        }
      }
      return;
    }
    if (!get(prev_value) || strict_equals(JSON.stringify(value()[itemId()]), JSON.stringify(get(prev_value)[itemId()]), false)) {
      dispatch("input", value());
    }
  }
  function setupMulti() {
    if (value()) {
      if (Array.isArray(value())) {
        value([...value()]);
      } else {
        value([value()]);
      }
    }
  }
  function setupSingle() {
    if (value()) value(null);
  }
  function setValueIndexAsHoverIndex() {
    const valueIndex = get(filteredItems).findIndex((i) => {
      return strict_equals(i[itemId()], value()[itemId()]);
    });
    checkHoverSelectable(valueIndex, true);
  }
  function dispatchHover(i) {
    dispatch("hoverItem", i);
  }
  function checkHoverSelectable(startingIndex = 0, ignoreGroup) {
    hoverItemIndex(startingIndex < 0 ? 0 : startingIndex);
    if (!ignoreGroup && groupBy() && get(filteredItems)[hoverItemIndex()] && !get(filteredItems)[hoverItemIndex()].selectable) {
      setHoverIndex(1);
    }
  }
  function setupFilterText() {
    if (!loadOptions() && strict_equals(filterText().length, 0)) return;
    if (loadOptions()) {
      debounce()(
        async function() {
          loading(true);
          let res = (await track_reactivity_loss(getItems2()({
            dispatch,
            loadOptions: loadOptions(),
            convertStringItemsToObjects,
            filterText: filterText()
          })))();
          if (res) {
            loading(res.loading);
            listOpen(listOpen() ? res.listOpen : filterText().length > 0 ? true : false);
            focused(listOpen() && res.focused);
            items(groupBy() ? filterGroupedItems(res.filteredItems) : res.filteredItems);
          } else {
            loading(false);
            focused(true);
            listOpen(true);
          }
        },
        debounceWait()
      );
    } else {
      listOpen(true);
      if (multiple()) {
        set(activeValue, void 0);
      }
    }
  }
  function handleFilterEvent(items2) {
    if (listOpen()) dispatch("filter", items2);
  }
  beforeUpdate(async () => {
    set(prev_value, value());
    set(prev_filterText, filterText());
    set(prev_multiple, multiple());
  });
  function computeJustValue() {
    if (multiple()) return value() ? value().map((item) => item[itemId()]) : null;
    return value() ? value()[itemId()] : value();
  }
  function checkValueForDuplicates() {
    let noDuplicates = true;
    if (value()) {
      const ids = [];
      const uniqueValues = [];
      value().forEach((val) => {
        if (!ids.includes(val[itemId()])) {
          ids.push(val[itemId()]);
          uniqueValues.push(val);
        } else {
          noDuplicates = false;
        }
      });
      if (!noDuplicates) value(uniqueValues);
    }
    return noDuplicates;
  }
  function findItem(selection) {
    let matchTo = selection ? selection[itemId()] : value()[itemId()];
    return items().find((item) => strict_equals(item[itemId()], matchTo));
  }
  function updateValueDisplay(items2) {
    if (!items2 || strict_equals(items2.length, 0) || items2.some((item) => strict_equals(typeof item, "object", false))) return;
    if (!value() || (multiple() ? value().some((selection) => !selection || !selection[itemId()]) : !value()[itemId()])) return;
    if (Array.isArray(value())) {
      value(value().map((selection) => findItem(selection) || selection));
    } else {
      value(findItem() || value());
    }
  }
  async function handleMultiItemClear(i) {
    const itemToRemove = value()[i];
    if (strict_equals(value().length, 1)) {
      value(void 0);
    } else {
      value(value().filter((item) => {
        return strict_equals(item, itemToRemove, false);
      }));
    }
    dispatch("clear", itemToRemove);
  }
  function handleKeyDown(e) {
    if (!focused()) return;
    e.stopPropagation();
    switch (e.key) {
      case "Escape":
        e.preventDefault();
        closeList();
        break;
      case "Enter":
        e.preventDefault();
        if (listOpen()) {
          if (strict_equals(get(filteredItems).length, 0)) break;
          const hoverItem = get(filteredItems)[hoverItemIndex()];
          if (value() && !multiple() && strict_equals(value()[itemId()], hoverItem[itemId()])) {
            closeList();
            break;
          } else {
            handleSelect(get(filteredItems)[hoverItemIndex()]);
          }
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        if (listOpen()) {
          setHoverIndex(1);
        } else {
          listOpen(true);
          set(activeValue, void 0);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (listOpen()) {
          setHoverIndex(-1);
        } else {
          listOpen(true);
          set(activeValue, void 0);
        }
        break;
      case "Tab":
        if (listOpen() && focused()) {
          if (strict_equals(get(filteredItems).length, 0) || value() && strict_equals(value()[itemId()], get(filteredItems)[hoverItemIndex()][itemId()])) return closeList();
          e.preventDefault();
          handleSelect(get(filteredItems)[hoverItemIndex()]);
          closeList();
        }
        break;
      case "Backspace":
        if (!multiple() || filterText().length > 0) return;
        if (multiple() && value() && value().length > 0) {
          handleMultiItemClear(strict_equals(get(activeValue), void 0, false) ? get(activeValue) : value().length - 1);
          if (strict_equals(get(activeValue), 0) || strict_equals(get(activeValue), void 0)) break;
          set(activeValue, value().length > get(activeValue) ? get(activeValue) - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!value() || !multiple() || filterText().length > 0) return;
        if (strict_equals(get(activeValue), void 0)) {
          set(activeValue, value().length - 1);
        } else if (value().length > get(activeValue) && strict_equals(get(activeValue), 0, false)) {
          set(activeValue, get(activeValue) - 1);
        }
        break;
      case "ArrowRight":
        if (!value() || !multiple() || filterText().length > 0 || strict_equals(get(activeValue), void 0)) return;
        if (strict_equals(get(activeValue), value().length - 1)) {
          set(activeValue, void 0);
        } else if (get(activeValue) < value().length - 1) {
          set(activeValue, get(activeValue) + 1);
        }
        break;
    }
  }
  function handleFocus(e) {
    var _a;
    if (focused() && strict_equals(input(), document == null ? void 0 : document.activeElement)) return;
    if (e) dispatch("focus", e);
    (_a = input()) == null ? void 0 : _a.focus();
    focused(true);
  }
  async function handleBlur(e) {
    var _a;
    if (isScrolling) return;
    if (listOpen() || focused()) {
      dispatch("blur", e);
      closeList();
      focused(false);
      set(activeValue, void 0);
      (_a = input()) == null ? void 0 : _a.blur();
    }
  }
  function handleClick() {
    if (disabled()) return;
    if (filterText().length > 0) return listOpen(true);
    listOpen(!listOpen());
  }
  function handleClear() {
    dispatch("clear", value());
    value(void 0);
    closeList();
    handleFocus();
  }
  onMount(() => {
    if (listOpen()) focused(true);
    if (focused() && input()) input().focus();
  });
  function itemSelected(selection) {
    if (selection) {
      filterText("");
      const item = Object.assign({}, selection);
      if (item.groupHeader && !item.selectable) return;
      value(multiple() ? value() ? value().concat([item]) : [item] : value(item));
      setTimeout(() => {
        if (closeListOnChange()) closeList();
        set(activeValue, void 0);
        dispatch("change", value());
        dispatch("select", selection);
      });
    }
  }
  function closeList() {
    if (clearFilterTextOnBlur()) {
      filterText("");
    }
    listOpen(false);
  }
  let ariaValues = prop($$props, "ariaValues", 8, (values) => {
    return `Option ${values}, selected.`;
  });
  let ariaListOpen = prop($$props, "ariaListOpen", 8, (label2, count) => {
    return `You are currently focused on option ${label2}. There are ${count} results available.`;
  });
  let ariaFocused = prop($$props, "ariaFocused", 8, () => {
    return `Select is focused, type to refine list, press down to open the menu.`;
  });
  function handleAriaSelection(_multiple) {
    let selected = void 0;
    if (_multiple && value().length > 0) {
      selected = value().map((v) => v[label()]).join(", ");
    } else {
      selected = value()[label()];
    }
    return ariaValues()(selected);
  }
  function handleAriaContent() {
    if (!get(filteredItems) || strict_equals(get(filteredItems).length, 0)) return "";
    let _item = get(filteredItems)[hoverItemIndex()];
    if (listOpen() && _item) {
      let count = get(filteredItems) ? get(filteredItems).length : 0;
      return ariaListOpen()(_item[label()], count);
    } else {
      return ariaFocused()();
    }
  }
  let list = mutable_source(null);
  let isScrollingTimer;
  function handleListScroll() {
    clearTimeout(isScrollingTimer);
    isScrollingTimer = setTimeout(
      () => {
        isScrolling = false;
      },
      100
    );
  }
  function handleClickOutside(event2) {
    var _a;
    if (!listOpen() && !focused() && container() && !container().contains(event2.target) && !((_a = get(list)) == null ? void 0 : _a.contains(event2.target))) {
      handleBlur();
    }
  }
  onDestroy(() => {
    var _a;
    (_a = get(list)) == null ? void 0 : _a.remove();
  });
  let isScrolling = false;
  function handleSelect(item) {
    if (!item || strict_equals(item.selectable, false)) return;
    itemSelected(item);
  }
  function handleHover(i) {
    if (isScrolling) return;
    hoverItemIndex(i);
  }
  function handleItemClick(args) {
    const { item, i } = args;
    if (strict_equals(item == null ? void 0 : item.selectable, false)) return;
    if (value() && !multiple() && strict_equals(value()[itemId()], item[itemId()])) return closeList();
    if (isItemSelectable(item)) {
      hoverItemIndex(i);
      handleSelect(item);
    }
  }
  function setHoverIndex(increment) {
    let selectableFilteredItems = get(filteredItems).filter((item) => !Object.hasOwn(item, "selectable") || strict_equals(item.selectable, true));
    if (strict_equals(selectableFilteredItems.length, 0)) {
      return hoverItemIndex(0);
    }
    if (increment > 0 && strict_equals(hoverItemIndex(), get(filteredItems).length - 1)) {
      hoverItemIndex(0);
    } else if (increment < 0 && strict_equals(hoverItemIndex(), 0)) {
      hoverItemIndex(get(filteredItems).length - 1);
    } else {
      hoverItemIndex(hoverItemIndex() + increment);
    }
    const hover = get(filteredItems)[hoverItemIndex()];
    if (hover && strict_equals(hover.selectable, false)) {
      if (strict_equals(increment, 1) || strict_equals(increment, -1)) setHoverIndex(increment);
      return;
    }
  }
  function isItemActive(item, value2, itemId2) {
    if (multiple()) return;
    return value2 && strict_equals(value2[itemId2], item[itemId2]);
  }
  function isItemFirst(itemIndex) {
    return strict_equals(itemIndex, 0);
  }
  function isItemSelectable(item) {
    return item.groupHeader && item.selectable || item.selectable || !item.hasOwnProperty("selectable");
  }
  const activeScroll = scrollAction;
  const hoverScroll = scrollAction;
  function scrollAction(node) {
    return {
      update(args) {
        if (args.scroll) {
          handleListScroll();
          node.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      }
    };
  }
  function setListWidth() {
    const { width } = container().getBoundingClientRect();
    mutate(list, get(list).style.width = listAutoWidth() ? width + "px" : "auto");
  }
  let _floatingConfig = mutable_source({
    strategy: "absolute",
    placement: "bottom-start",
    middleware: [offset2(listOffset()), flip2(), shift2()],
    autoUpdate: false
  });
  const [floatingRef, floatingContent, floatingUpdate] = createFloatingActions(get(_floatingConfig));
  let prefloat = mutable_source(true);
  function listMounted(list2, listOpen2) {
    if (!list2 || !listOpen2) return set(prefloat, true);
    setTimeout(
      () => {
        set(prefloat, false);
      },
      0
    );
  }
  legacy_pre_effect(() => (deep_read_state(items()), deep_read_state(value())), () => {
    if (items(), value()) setValue();
  });
  legacy_pre_effect(
    () => (deep_read_state(inputAttributes()), deep_read_state(searchable())),
    () => {
      if (inputAttributes() || !searchable()) assignInputAttributes();
    }
  );
  legacy_pre_effect(() => deep_read_state(multiple()), () => {
    if (multiple()) setupMulti();
  });
  legacy_pre_effect(() => (get(prev_multiple), deep_read_state(multiple())), () => {
    if (get(prev_multiple) && !multiple()) setupSingle();
  });
  legacy_pre_effect(() => (deep_read_state(multiple()), deep_read_state(value())), () => {
    if (multiple() && value() && value().length > 1) checkValueForDuplicates();
  });
  legacy_pre_effect(() => deep_read_state(value()), () => {
    if (value()) dispatchSelectedItem();
  });
  legacy_pre_effect(
    () => (deep_read_state(value()), deep_read_state(multiple()), get(prev_value)),
    () => {
      if (!value() && multiple() && get(prev_value)) dispatch("input", value());
    }
  );
  legacy_pre_effect(() => (deep_read_state(focused()), deep_read_state(input())), () => {
    if (!focused() && input()) closeList();
  });
  legacy_pre_effect(() => (deep_read_state(filterText()), get(prev_filterText)), () => {
    if (strict_equals(filterText(), get(prev_filterText), false)) setupFilterText();
  });
  legacy_pre_effect(
    () => (deep_read_state(filter2()), deep_read_state(loadOptions()), deep_read_state(filterText()), deep_read_state(items()), deep_read_state(multiple()), deep_read_state(value()), deep_read_state(itemId()), deep_read_state(groupBy()), deep_read_state(label()), deep_read_state(filterSelectedItems()), deep_read_state(itemFilter())),
    () => {
      set(filteredItems, filter2()({
        loadOptions: loadOptions(),
        filterText: filterText(),
        items: items(),
        multiple: multiple(),
        value: value(),
        itemId: itemId(),
        groupBy: groupBy(),
        label: label(),
        filterSelectedItems: filterSelectedItems(),
        itemFilter: itemFilter(),
        convertStringItemsToObjects,
        filterGroupedItems
      }));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(multiple()), deep_read_state(listOpen()), deep_read_state(value()), get(filteredItems)),
    () => {
      if (!multiple() && listOpen() && value() && get(filteredItems)) setValueIndexAsHoverIndex();
    }
  );
  legacy_pre_effect(() => (deep_read_state(listOpen()), deep_read_state(multiple())), () => {
    if (listOpen() && multiple()) hoverItemIndex(0);
  });
  legacy_pre_effect(() => deep_read_state(filterText()), () => {
    if (filterText()) hoverItemIndex(0);
  });
  legacy_pre_effect(() => deep_read_state(hoverItemIndex()), () => {
    dispatchHover(hoverItemIndex());
  });
  legacy_pre_effect(() => (deep_read_state(multiple()), deep_read_state(value())), () => {
    set(hasValue, multiple() ? value() && value().length > 0 : value());
  });
  legacy_pre_effect(() => (get(hasValue), deep_read_state(filterText())), () => {
    set(hideSelectedItem, get(hasValue) && filterText().length > 0);
  });
  legacy_pre_effect(
    () => (get(hasValue), deep_read_state(clearable()), deep_read_state(disabled()), deep_read_state(loading())),
    () => {
      set(showClear, get(hasValue) && clearable() && !disabled() && !loading());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(placeholderAlwaysShow()), deep_read_state(multiple()), deep_read_state(placeholder()), deep_read_state(value())),
    () => {
      var _a;
      set(placeholderText, placeholderAlwaysShow() && multiple() ? placeholder() : multiple() && strict_equals((_a = value()) == null ? void 0 : _a.length, 0) ? placeholder() : value() ? "" : placeholder());
    }
  );
  legacy_pre_effect(() => (deep_read_state(value()), deep_read_state(multiple())), () => {
    set(ariaSelection, value() ? handleAriaSelection(multiple()) : "");
  });
  legacy_pre_effect(
    () => (get(filteredItems), deep_read_state(hoverItemIndex()), deep_read_state(focused()), deep_read_state(listOpen())),
    () => {
      set(ariaContext, handleAriaContent({
        filteredItems: get(filteredItems),
        hoverItemIndex: hoverItemIndex(),
        focused: focused(),
        listOpen: listOpen()
      }));
    }
  );
  legacy_pre_effect(() => deep_read_state(items()), () => {
    updateValueDisplay(items());
  });
  legacy_pre_effect(
    () => (deep_read_state(multiple()), deep_read_state(value()), deep_read_state(itemId())),
    () => {
      justValue(computeJustValue(multiple(), value(), itemId()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(multiple()), get(prev_value), deep_read_state(value())),
    () => {
      if (!multiple() && get(prev_value) && !value()) dispatch("input", value());
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(listOpen()), get(filteredItems), deep_read_state(multiple()), deep_read_state(value())),
    () => {
      if (listOpen() && get(filteredItems) && !multiple() && !value()) checkHoverSelectable();
    }
  );
  legacy_pre_effect(() => get(filteredItems), () => {
    handleFilterEvent(get(filteredItems));
  });
  legacy_pre_effect(
    () => (deep_read_state(container()), deep_read_state(floatingConfig()), get(_floatingConfig)),
    () => {
      if (container() && floatingConfig()) floatingUpdate(Object.assign(get(_floatingConfig), floatingConfig()));
    }
  );
  legacy_pre_effect(() => get(list), () => {
    set(listDom, !!get(list));
  });
  legacy_pre_effect(() => (get(list), deep_read_state(listOpen())), () => {
    listMounted(get(list), listOpen());
  });
  legacy_pre_effect(
    () => (deep_read_state(listOpen()), deep_read_state(container()), get(list)),
    () => {
      if (listOpen() && container() && get(list)) setListWidth();
    }
  );
  legacy_pre_effect(() => deep_read_state(hoverItemIndex()), () => {
    set(scrollToHoverItem, hoverItemIndex());
  });
  legacy_pre_effect(
    () => (deep_read_state(input()), deep_read_state(listOpen()), deep_read_state(focused())),
    () => {
      if (input() && listOpen() && !focused()) handleFocus();
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(container()), deep_read_state(floatingConfig())),
    () => {
      var _a;
      if (container() && strict_equals((_a = floatingConfig()) == null ? void 0 : _a.autoUpdate, void 0)) {
        mutate(_floatingConfig, get(_floatingConfig).autoUpdate = true);
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root4();
  event("click", $window, handleClickOutside);
  event("keydown", $window, handleKeyDown);
  let classes;
  var node_1 = child(div);
  {
    var consequent_5 = ($$anchor2) => {
      var div_1 = root_1();
      let classes_1;
      var node_2 = child(div_1);
      {
        var consequent = ($$anchor3) => {
          var fragment = comment();
          var node_3 = first_child(fragment);
          slot(node_3, $$props, "list-prepend", {}, null);
          append($$anchor3, fragment);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if (untrack(() => $$slots["list-prepend"])) $$render(consequent);
          }),
          "if",
          Select,
          696,
          12
        );
      }
      var node_4 = sibling(node_2, 2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_5 = first_child(fragment_1);
          slot(
            node_5,
            $$props,
            "list",
            {
              get filteredItems() {
                return get(filteredItems);
              }
            },
            null
          );
          append($$anchor3, fragment_1);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_6 = first_child(fragment_2);
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_3 = comment();
              var node_7 = first_child(fragment_3);
              add_svelte_meta(
                () => each(node_7, 1, () => get(filteredItems), index, ($$anchor5, item, i) => {
                  var div_2 = root_6();
                  var div_3 = child(div_2);
                  let classes_2;
                  var node_8 = child(div_3);
                  slot(
                    node_8,
                    $$props,
                    "item",
                    {
                      get item() {
                        return get(item);
                      },
                      index: i
                    },
                    ($$anchor6) => {
                      var text2 = text();
                      template_effect(() => set_text(text2, (get(item), deep_read_state(label()), untrack(() => {
                        var _a;
                        return (_a = get(item)) == null ? void 0 : _a[label()];
                      }))));
                      append($$anchor6, text2);
                    }
                  );
                  reset(div_3);
                  action(div_3, ($$node, $$action_arg) => activeScroll == null ? void 0 : activeScroll($$node, $$action_arg), () => ({
                    scroll: isItemActive(get(item), value(), itemId()),
                    listDom: get(listDom)
                  }));
                  action(div_3, ($$node, $$action_arg) => hoverScroll == null ? void 0 : hoverScroll($$node, $$action_arg), () => ({
                    scroll: strict_equals(get(scrollToHoverItem), i),
                    listDom: get(listDom)
                  }));
                  reset(div_2);
                  template_effect(($0) => classes_2 = set_class(div_3, 1, "item s-413vZPMk7oiT", null, classes_2, $0), [
                    () => {
                      var _a;
                      return {
                        "list-group-title": get(item).groupHeader,
                        active: isItemActive(get(item), value(), itemId()),
                        first: isItemFirst(i),
                        hover: strict_equals(hoverItemIndex(), i),
                        "group-item": get(item).groupItem,
                        "not-selectable": strict_equals((_a = get(item)) == null ? void 0 : _a.selectable, false)
                      };
                    }
                  ]);
                  event("mouseover", div_2, () => handleHover(i));
                  event("focus", div_2, () => handleHover(i));
                  event("click", div_2, stopPropagation(() => handleItemClick({ item: get(item), i })));
                  event("keydown", div_2, preventDefault(stopPropagation(function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  })));
                  append($$anchor5, div_2);
                }),
                "each",
                Select,
                699,
                16
              );
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var fragment_5 = comment();
              var node_9 = first_child(fragment_5);
              {
                var consequent_3 = ($$anchor5) => {
                  var fragment_6 = comment();
                  var node_10 = first_child(fragment_6);
                  slot(node_10, $$props, "empty", {}, ($$anchor6) => {
                    var div_4 = root_10();
                    append($$anchor6, div_4);
                  });
                  append($$anchor5, fragment_6);
                };
                add_svelte_meta(
                  () => if_block(
                    node_9,
                    ($$render) => {
                      if (!hideEmptyState()) $$render(consequent_3);
                    },
                    true
                  ),
                  "if",
                  Select,
                  724,
                  12
                );
              }
              append($$anchor4, fragment_5);
            };
            add_svelte_meta(
              () => if_block(
                node_6,
                ($$render) => {
                  if (get(filteredItems), untrack(() => get(filteredItems).length > 0)) $$render(consequent_2);
                  else $$render(alternate, false);
                },
                true
              ),
              "if",
              Select,
              698,
              12
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_4, ($$render) => {
            if (untrack(() => $$slots.list)) $$render(consequent_1);
            else $$render(alternate_1, false);
          }),
          "if",
          Select,
          697,
          12
        );
      }
      var node_11 = sibling(node_4, 2);
      {
        var consequent_4 = ($$anchor3) => {
          var fragment_7 = comment();
          var node_12 = first_child(fragment_7);
          slot(node_12, $$props, "list-append", {}, null);
          append($$anchor3, fragment_7);
        };
        add_svelte_meta(
          () => if_block(node_11, ($$render) => {
            if (untrack(() => $$slots["list-append"])) $$render(consequent_4);
          }),
          "if",
          Select,
          729,
          12
        );
      }
      reset(div_1);
      action(div_1, ($$node) => floatingContent == null ? void 0 : floatingContent($$node));
      bind_this(div_1, ($$value) => set(list, $$value), () => get(list));
      effect(() => event("scroll", div_1, handleListScroll));
      effect(() => event("pointerup", div_1, preventDefault(stopPropagation(function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }))));
      effect(() => event("mousedown", div_1, preventDefault(stopPropagation(function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }))));
      template_effect(($0) => classes_1 = set_class(div_1, 1, "svelte-select-list s-413vZPMk7oiT", null, classes_1, $0), [() => ({ prefloat: get(prefloat) })]);
      append($$anchor2, div_1);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (listOpen()) $$render(consequent_5);
      }),
      "if",
      Select,
      686,
      4
    );
  }
  var span = sibling(node_1, 2);
  var node_13 = child(span);
  {
    var consequent_6 = ($$anchor2) => {
      var fragment_8 = root_12();
      var span_1 = first_child(fragment_8);
      var text_1 = child(span_1, true);
      reset(span_1);
      var span_2 = sibling(span_1, 2);
      var text_2 = child(span_2, true);
      reset(span_2);
      template_effect(() => {
        set_text(text_1, get(ariaSelection));
        set_text(text_2, get(ariaContext));
      });
      append($$anchor2, fragment_8);
    };
    add_svelte_meta(
      () => if_block(node_13, ($$render) => {
        if (focused()) $$render(consequent_6);
      }),
      "if",
      Select,
      734,
      8
    );
  }
  reset(span);
  var div_5 = sibling(span, 2);
  var node_14 = child(div_5);
  slot(node_14, $$props, "prepend", {}, null);
  reset(div_5);
  var div_6 = sibling(div_5, 2);
  var node_15 = child(div_6);
  {
    var consequent_9 = ($$anchor2) => {
      var fragment_9 = comment();
      var node_16 = first_child(fragment_9);
      {
        var consequent_8 = ($$anchor3) => {
          var fragment_10 = comment();
          var node_17 = first_child(fragment_10);
          add_svelte_meta(
            () => each(node_17, 1, value, index, ($$anchor4, item, i) => {
              var div_7 = root_15();
              let classes_3;
              var span_3 = child(div_7);
              var node_18 = child(span_3);
              slot(
                node_18,
                $$props,
                "selection",
                {
                  get selection() {
                    return get(item);
                  },
                  index: i
                },
                ($$anchor5) => {
                  var text_3 = text();
                  template_effect(() => set_text(text_3, (get(item), deep_read_state(label()), untrack(() => get(item)[label()]))));
                  append($$anchor5, text_3);
                }
              );
              reset(span_3);
              var node_19 = sibling(span_3, 2);
              {
                var consequent_7 = ($$anchor5) => {
                  var div_8 = root_17();
                  var node_20 = child(div_8);
                  slot(node_20, $$props, "multi-clear-icon", {}, ($$anchor6) => {
                    var fragment_12 = comment();
                    var node_21 = first_child(fragment_12);
                    add_svelte_meta(() => ClearIcon_default(node_21, {}), "component", Select, 768, 36, { componentTag: "ClearIcon" });
                    append($$anchor6, fragment_12);
                  });
                  reset(div_8);
                  event("pointerup", div_8, preventDefault(stopPropagation(() => handleMultiItemClear(i))));
                  append($$anchor5, div_8);
                };
                add_svelte_meta(
                  () => if_block(node_19, ($$render) => {
                    if (!disabled() && !multiFullItemClearable() && ClearIcon_default) $$render(consequent_7);
                  }),
                  "if",
                  Select,
                  763,
                  24
                );
              }
              reset(div_7);
              template_effect(($0) => classes_3 = set_class(div_7, 1, "multi-item s-413vZPMk7oiT", null, classes_3, $0), [
                () => ({
                  active: strict_equals(get(activeValue), i),
                  disabled: disabled()
                })
              ]);
              event("click", div_7, preventDefault(() => multiFullItemClearable() ? handleMultiItemClear(i) : {}));
              event("keydown", div_7, preventDefault(stopPropagation(function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              })));
              append($$anchor4, div_7);
            }),
            "each",
            Select,
            749,
            16
          );
          append($$anchor3, fragment_10);
        };
        var alternate_2 = ($$anchor3) => {
          var div_9 = root_19();
          let classes_4;
          var node_22 = child(div_9);
          slot(
            node_22,
            $$props,
            "selection",
            {
              get selection() {
                return value();
              }
            },
            ($$anchor4) => {
              var text_4 = text();
              template_effect(() => set_text(text_4, (deep_read_state(value()), deep_read_state(label()), untrack(() => value()[label()]))));
              append($$anchor4, text_4);
            }
          );
          reset(div_9);
          template_effect(($0) => classes_4 = set_class(div_9, 1, "selected-item s-413vZPMk7oiT", null, classes_4, $0), [() => ({ "hide-selected-item": get(hideSelectedItem) })]);
          append($$anchor3, div_9);
        };
        add_svelte_meta(
          () => if_block(node_16, ($$render) => {
            if (multiple()) $$render(consequent_8);
            else $$render(alternate_2, false);
          }),
          "if",
          Select,
          748,
          12
        );
      }
      append($$anchor2, fragment_9);
    };
    add_svelte_meta(
      () => if_block(node_15, ($$render) => {
        if (get(hasValue)) $$render(consequent_9);
      }),
      "if",
      Select,
      747,
      8
    );
  }
  var input_1 = sibling(node_15, 2);
  remove_input_defaults(input_1);
  attribute_effect(
    input_1,
    () => ({
      readOnly: !searchable(),
      ...get(_inputAttributes),
      placeholder: get(placeholderText),
      style: inputStyles(),
      disabled: disabled()
    }),
    void 0,
    void 0,
    "s-413vZPMk7oiT"
  );
  bind_this(input_1, ($$value) => input($$value), () => input());
  reset(div_6);
  var div_10 = sibling(div_6, 2);
  var node_23 = child(div_10);
  {
    var consequent_10 = ($$anchor2) => {
      var div_11 = root_21();
      var node_24 = child(div_11);
      slot(node_24, $$props, "loading-icon", {}, ($$anchor3) => {
        var fragment_14 = comment();
        var node_25 = first_child(fragment_14);
        add_svelte_meta(() => LoadingIcon_default(node_25, {}), "component", Select, 800, 20, { componentTag: "LoadingIcon" });
        append($$anchor3, fragment_14);
      });
      reset(div_11);
      append($$anchor2, div_11);
    };
    add_svelte_meta(
      () => if_block(node_23, ($$render) => {
        if (loading()) $$render(consequent_10);
      }),
      "if",
      Select,
      797,
      8
    );
  }
  var node_26 = sibling(node_23, 2);
  {
    var consequent_11 = ($$anchor2) => {
      var button = root_23();
      var node_27 = child(button);
      slot(node_27, $$props, "clear-icon", {}, ($$anchor3) => {
        var fragment_15 = comment();
        var node_28 = first_child(fragment_15);
        add_svelte_meta(() => ClearIcon_default(node_28, {}), "component", Select, 808, 20, { componentTag: "ClearIcon" });
        append($$anchor3, fragment_15);
      });
      reset(button);
      event("click", button, handleClear);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node_26, ($$render) => {
        if (get(showClear)) $$render(consequent_11);
      }),
      "if",
      Select,
      805,
      8
    );
  }
  var node_29 = sibling(node_26, 2);
  {
    var consequent_12 = ($$anchor2) => {
      var div_12 = root_25();
      var node_30 = child(div_12);
      slot(
        node_30,
        $$props,
        "chevron-icon",
        {
          get listOpen() {
            return listOpen();
          }
        },
        ($$anchor3) => {
          var fragment_16 = comment();
          var node_31 = first_child(fragment_16);
          add_svelte_meta(() => ChevronIcon_default(node_31, {}), "component", Select, 816, 20, { componentTag: "ChevronIcon" });
          append($$anchor3, fragment_16);
        }
      );
      reset(div_12);
      append($$anchor2, div_12);
    };
    add_svelte_meta(
      () => if_block(node_29, ($$render) => {
        if (showChevron()) $$render(consequent_12);
      }),
      "if",
      Select,
      813,
      8
    );
  }
  reset(div_10);
  var node_32 = sibling(div_10, 2);
  slot(
    node_32,
    $$props,
    "input-hidden",
    {
      get value() {
        return value();
      }
    },
    ($$anchor2) => {
      var input_2 = root_27();
      remove_input_defaults(input_2);
      template_effect(
        ($0) => {
          set_attribute(input_2, "name", name());
          set_value(input_2, $0);
        },
        [
          () => (deep_read_state(value()), untrack(() => value() ? JSON.stringify(value()) : null))
        ]
      );
      append($$anchor2, input_2);
    }
  );
  var node_33 = sibling(node_32, 2);
  {
    var consequent_13 = ($$anchor2) => {
      var fragment_17 = comment();
      var node_34 = first_child(fragment_17);
      slot(
        node_34,
        $$props,
        "required",
        {
          get value() {
            return value();
          }
        },
        ($$anchor3) => {
          var select = root_29();
          append($$anchor3, select);
        }
      );
      append($$anchor2, fragment_17);
    };
    add_svelte_meta(
      () => if_block(node_33, ($$render) => {
        if (deep_read_state(required()), deep_read_state(value()), untrack(() => required() && (!value() || strict_equals(value().length, 0)))) $$render(consequent_13);
      }),
      "if",
      Select,
      826,
      4
    );
  }
  reset(div);
  effect(() => event("pointerup", div, preventDefault(handleClick)));
  bind_this(div, ($$value) => container($$value), () => container());
  action(div, ($$node) => floatingRef == null ? void 0 : floatingRef($$node));
  template_effect(
    ($0) => {
      classes = set_class(div, 1, `svelte-select ${containerClasses() ?? ""}`, "s-413vZPMk7oiT", classes, $0);
      set_style(div, containerStyles());
    },
    [
      () => ({
        multi: multiple(),
        disabled: disabled(),
        focused: focused(),
        "list-open": listOpen(),
        "show-chevron": showChevron(),
        error: hasError()
      })
    ]
  );
  event("keydown", input_1, handleKeyDown);
  event("blur", input_1, handleBlur);
  event("focus", input_1, handleFocus);
  bind_value(input_1, filterText);
  append($$anchor, div);
  bind_prop($$props, "getFilteredItems", getFilteredItems);
  bind_prop($$props, "handleClear", handleClear);
  return pop({
    get getFilteredItems() {
      return getFilteredItems;
    },
    get handleClear() {
      return handleClear;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Select = hmr(Select, () => Select[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-413vZPMk7oiT");
    module.default[HMR].source = Select[HMR].source;
    set(Select[HMR].source, module.default[HMR].original);
  });
}
var Select_default = Select;
export {
  Select_default as default
};
//# sourceMappingURL=svelte-select.js.map
